/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_EAL_PMD_PATH: &'static [u8; 47usize] =
    b"/usr/local/lib/x86_64-linux-gnu/dpdk/pmds-20.0\0";
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_HAS_LIBNUMA: u32 = 1;
pub const RTE_IXGBE_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_ACL: u32 = 1;
pub const RTE_LIBRTE_AF_PACKET_PMD: u32 = 1;
pub const RTE_LIBRTE_ARK_PMD: u32 = 1;
pub const RTE_LIBRTE_ATLANTIC_PMD: u32 = 1;
pub const RTE_LIBRTE_AVP_PMD: u32 = 1;
pub const RTE_LIBRTE_AXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_BBDEV: u32 = 1;
pub const RTE_LIBRTE_BITRATESTATS: u32 = 1;
pub const RTE_LIBRTE_BNXT_PMD: u32 = 1;
pub const RTE_LIBRTE_BOND_PMD: u32 = 1;
pub const RTE_LIBRTE_BPF: u32 = 1;
pub const RTE_LIBRTE_BUCKET_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_CAAM_JR_PMD: u32 = 1;
pub const RTE_LIBRTE_CFGFILE: u32 = 1;
pub const RTE_LIBRTE_CMDLINE: u32 = 1;
pub const RTE_LIBRTE_COMPRESSDEV: u32 = 1;
pub const RTE_LIBRTE_CPT_COMMON: u32 = 1;
pub const RTE_LIBRTE_CRYPTODEV: u32 = 1;
pub const RTE_LIBRTE_CRYPTO_SCHEDULER_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_DISTRIBUTOR: u32 = 1;
pub const RTE_LIBRTE_DPAA2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA2_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAAX_COMMON: u32 = 1;
pub const RTE_LIBRTE_DPAA_BUS: u32 = 1;
pub const RTE_LIBRTE_DPAA_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DSW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_E1000_PMD: u32 = 1;
pub const RTE_LIBRTE_EAL: u32 = 1;
pub const RTE_LIBRTE_EFD: u32 = 1;
pub const RTE_LIBRTE_ENA_PMD: u32 = 1;
pub const RTE_LIBRTE_ENETC_PMD: u32 = 1;
pub const RTE_LIBRTE_ENIC_PMD: u32 = 1;
pub const RTE_LIBRTE_ETHDEV: u32 = 1;
pub const RTE_LIBRTE_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_FAILSAFE_PMD: u32 = 1;
pub const RTE_LIBRTE_FIB: u32 = 1;
pub const RTE_LIBRTE_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_FM10K_PMD: u32 = 1;
pub const RTE_LIBRTE_FSLMC_BUS: u32 = 1;
pub const RTE_LIBRTE_GRO: u32 = 1;
pub const RTE_LIBRTE_GSO: u32 = 1;
pub const RTE_LIBRTE_HASH: u32 = 1;
pub const RTE_LIBRTE_HINIC_PMD: u32 = 1;
pub const RTE_LIBRTE_HNS3_PMD: u32 = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_PMD: u32 = 1;
pub const RTE_LIBRTE_IAVF_PMD: u32 = 1;
pub const RTE_LIBRTE_ICE_PMD: u32 = 1;
pub const RTE_LIBRTE_IFC_PMD: u32 = 1;
pub const RTE_LIBRTE_IFPGA_BUS: u32 = 1;
pub const RTE_LIBRTE_IPSEC: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG: u32 = 1;
pub const RTE_LIBRTE_IXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_JOBSTATS: u32 = 1;
pub const RTE_LIBRTE_KNI: u32 = 1;
pub const RTE_LIBRTE_KNI_PMD: u32 = 1;
pub const RTE_LIBRTE_KVARGS: u32 = 1;
pub const RTE_LIBRTE_LATENCYSTATS: u32 = 1;
pub const RTE_LIBRTE_LIQUIDIO_PMD: u32 = 1;
pub const RTE_LIBRTE_LPM: u32 = 1;
pub const RTE_LIBRTE_MBUF: u32 = 1;
pub const RTE_LIBRTE_MEMBER: u32 = 1;
pub const RTE_LIBRTE_MEMIF_PMD: u32 = 1;
pub const RTE_LIBRTE_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_METER: u32 = 1;
pub const RTE_LIBRTE_METRICS: u32 = 1;
pub const RTE_LIBRTE_NET: u32 = 1;
pub const RTE_LIBRTE_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_NFP_PMD: u32 = 1;
pub const RTE_LIBRTE_NITROX_PMD: u32 = 1;
pub const RTE_LIBRTE_NULL_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_NULL_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMPRESS_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_PMD: u32 = 1;
pub const RTE_LIBRTE_OPDL_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_PCAP_PMD: u32 = 1;
pub const RTE_LIBRTE_PCI: u32 = 1;
pub const RTE_LIBRTE_PCI_BUS: u32 = 1;
pub const RTE_LIBRTE_PDUMP: u32 = 1;
pub const RTE_LIBRTE_PFE_PMD: u32 = 1;
pub const RTE_LIBRTE_PIPELINE: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_FPGA_LTE_FEC: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_NULL: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_TURBO_SW: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_CMDIF_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_QDMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_IOAT_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_NTB_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX2_DMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SKELETON_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PORT: u32 = 1;
pub const RTE_LIBRTE_POWER: u32 = 1;
pub const RTE_LIBRTE_QAT_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_PMD: u32 = 1;
pub const RTE_LIBRTE_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_RCU: u32 = 1;
pub const RTE_LIBRTE_REORDER: u32 = 1;
pub const RTE_LIBRTE_RIB: u32 = 1;
pub const RTE_LIBRTE_RING: u32 = 1;
pub const RTE_LIBRTE_RING_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_RING_PMD: u32 = 1;
pub const RTE_LIBRTE_SCHED: u32 = 1;
pub const RTE_LIBRTE_SECURITY: u32 = 1;
pub const RTE_LIBRTE_SFC_PMD: u32 = 1;
pub const RTE_LIBRTE_SKELETON_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_SOFTNIC_PMD: u32 = 1;
pub const RTE_LIBRTE_STACK: u32 = 1;
pub const RTE_LIBRTE_STACK_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_SW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_TABLE: u32 = 1;
pub const RTE_LIBRTE_TAP_PMD: u32 = 1;
pub const RTE_LIBRTE_THUNDERX_PMD: u32 = 1;
pub const RTE_LIBRTE_TIMER: u32 = 1;
pub const RTE_LIBRTE_VDEV_BUS: u32 = 1;
pub const RTE_LIBRTE_VDEV_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_VHOST: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIBRTE_VHOST_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: u32 = 1;
pub const RTE_LIBRTE_VMBUS_BUS: u32 = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AES: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AVX: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AVX2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_PCLMULQDQ: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_RDRAND: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_RDSEED: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE3: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE4_1: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE4_2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSSE3: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_NUMA_NODES: u32 = 4;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_PORT_PCAP: u32 = 1;
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\0";
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const RTE_VER_MINOR: u32 = 1;
pub const RTE_VER_MONTH: u32 = 11;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &'static [u8; 1usize] = b"\0";
pub const RTE_VER_YEAR: u32 = 19;
pub const RTE_VIRTIO_USER: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &'static [u8; 5usize] = b"DPDK\0";
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] = b"ring_mp_mc\0";
pub const RTE_MBUF_REFCNT_ATOMIC: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 64;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 4;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_SCHED_PORT_N_GRINDERS: u32 = 8;
pub const RTE_KNI_PREEMPT_DEFAULT: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\0";
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_KNI: u32 = 8;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_GSO: u32 = 20;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_MP_MAX_FD_NUM: u32 = 8;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 512;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_MEMSEG_FLAG_DO_NOT_FREE: u32 = 1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &'static [u8; 9usize] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &'static [u8; 4usize] = b"RG_\0";
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &'static [u8; 4usize] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &'static [u8; 6usize] = b"MP_%s\0";
pub const MEMPOOL_PG_NUM_DEFAULT: u32 = 1;
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const MEMPOOL_F_NO_PHYS_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const PKT_RX_VLAN: u32 = 1;
pub const PKT_RX_RSS_HASH: u32 = 2;
pub const PKT_RX_FDIR: u32 = 4;
pub const PKT_RX_L4_CKSUM_BAD: u32 = 8;
pub const PKT_RX_IP_CKSUM_BAD: u32 = 16;
pub const PKT_RX_EIP_CKSUM_BAD: u32 = 32;
pub const PKT_RX_VLAN_STRIPPED: u32 = 64;
pub const PKT_RX_IP_CKSUM_MASK: u32 = 144;
pub const PKT_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_IP_CKSUM_GOOD: u32 = 128;
pub const PKT_RX_IP_CKSUM_NONE: u32 = 144;
pub const PKT_RX_L4_CKSUM_MASK: u32 = 264;
pub const PKT_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_L4_CKSUM_GOOD: u32 = 256;
pub const PKT_RX_L4_CKSUM_NONE: u32 = 264;
pub const PKT_RX_IEEE1588_PTP: u32 = 512;
pub const PKT_RX_IEEE1588_TMST: u32 = 1024;
pub const PKT_RX_FDIR_ID: u32 = 8192;
pub const PKT_RX_FDIR_FLX: u32 = 16384;
pub const PKT_RX_QINQ_STRIPPED: u32 = 32768;
pub const PKT_RX_LRO: u32 = 65536;
pub const PKT_RX_TIMESTAMP: u32 = 131072;
pub const PKT_RX_SEC_OFFLOAD: u32 = 262144;
pub const PKT_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const PKT_RX_QINQ: u32 = 1048576;
pub const PKT_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const PKT_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const PKT_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const PKT_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const PKT_FIRST_FREE: u32 = 8388608;
pub const PKT_LAST_FREE: u64 = 1099511627776;
pub const PKT_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const PKT_TX_UDP_SEG: u64 = 4398046511104;
pub const PKT_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const PKT_TX_MACSEC: u64 = 17592186044416;
pub const PKT_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const PKT_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const PKT_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const PKT_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const PKT_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const PKT_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const PKT_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const PKT_TX_TUNNEL_IP: u64 = 457396837154816;
pub const PKT_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const PKT_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const PKT_TX_QINQ: u64 = 562949953421312;
pub const PKT_TX_QINQ_PKT: u64 = 562949953421312;
pub const PKT_TX_TCP_SEG: u64 = 1125899906842624;
pub const PKT_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const PKT_TX_L4_NO_CKSUM: u32 = 0;
pub const PKT_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const PKT_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const PKT_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const PKT_TX_L4_MASK: u64 = 13510798882111488;
pub const PKT_TX_IP_CKSUM: u64 = 18014398509481984;
pub const PKT_TX_IPV4: u64 = 36028797018963968;
pub const PKT_TX_IPV6: u64 = 72057594037927936;
pub const PKT_TX_VLAN: u64 = 144115188075855872;
pub const PKT_TX_VLAN_PKT: u64 = 144115188075855872;
pub const PKT_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const PKT_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const PKT_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const PKT_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_ETHER_ADDR_LEN: u32 = 6;
pub const RTE_ETHER_TYPE_LEN: u32 = 2;
pub const RTE_ETHER_CRC_LEN: u32 = 4;
pub const RTE_ETHER_HDR_LEN: u32 = 14;
pub const RTE_ETHER_MIN_LEN: u32 = 64;
pub const RTE_ETHER_MAX_LEN: u32 = 1518;
pub const RTE_ETHER_MTU: u32 = 1500;
pub const RTE_ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const RTE_ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const RTE_ETHER_MAX_VLAN_ID: u32 = 4095;
pub const RTE_ETHER_MIN_MTU: u32 = 68;
pub const RTE_ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const RTE_ETHER_GROUP_ADDR: u32 = 1;
pub const RTE_ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const RTE_ETHER_TYPE_IPV4: u32 = 2048;
pub const RTE_ETHER_TYPE_IPV6: u32 = 34525;
pub const RTE_ETHER_TYPE_ARP: u32 = 2054;
pub const RTE_ETHER_TYPE_RARP: u32 = 32821;
pub const RTE_ETHER_TYPE_VLAN: u32 = 33024;
pub const RTE_ETHER_TYPE_QINQ: u32 = 34984;
pub const RTE_ETHER_TYPE_PPPOE_DISCOVERY: u32 = 34915;
pub const RTE_ETHER_TYPE_PPPOE_SESSION: u32 = 34916;
pub const RTE_ETHER_TYPE_ETAG: u32 = 35135;
pub const RTE_ETHER_TYPE_1588: u32 = 35063;
pub const RTE_ETHER_TYPE_SLOW: u32 = 34825;
pub const RTE_ETHER_TYPE_TEB: u32 = 25944;
pub const RTE_ETHER_TYPE_LLDP: u32 = 35020;
pub const RTE_ETHER_TYPE_MPLS: u32 = 34887;
pub const RTE_ETHER_TYPE_MPLSM: u32 = 34888;
pub const RTE_ETH_MODULE_SFF_8079: u32 = 1;
pub const RTE_ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8472: u32 = 2;
pub const RTE_ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const RTE_ETH_MODULE_SFF_8636: u32 = 3;
pub const RTE_ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const RTE_ETH_MODULE_SFF_8436: u32 = 4;
pub const RTE_ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const ETH_LINK_SPEED_FIXED: u32 = 1;
pub const ETH_LINK_SPEED_10M_HD: u32 = 2;
pub const ETH_LINK_SPEED_10M: u32 = 4;
pub const ETH_LINK_SPEED_100M_HD: u32 = 8;
pub const ETH_LINK_SPEED_100M: u32 = 16;
pub const ETH_LINK_SPEED_1G: u32 = 32;
pub const ETH_LINK_SPEED_2_5G: u32 = 64;
pub const ETH_LINK_SPEED_5G: u32 = 128;
pub const ETH_LINK_SPEED_10G: u32 = 256;
pub const ETH_LINK_SPEED_20G: u32 = 512;
pub const ETH_LINK_SPEED_25G: u32 = 1024;
pub const ETH_LINK_SPEED_40G: u32 = 2048;
pub const ETH_LINK_SPEED_50G: u32 = 4096;
pub const ETH_LINK_SPEED_56G: u32 = 8192;
pub const ETH_LINK_SPEED_100G: u32 = 16384;
pub const ETH_SPEED_NUM_NONE: u32 = 0;
pub const ETH_SPEED_NUM_10M: u32 = 10;
pub const ETH_SPEED_NUM_100M: u32 = 100;
pub const ETH_SPEED_NUM_1G: u32 = 1000;
pub const ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const ETH_SPEED_NUM_5G: u32 = 5000;
pub const ETH_SPEED_NUM_10G: u32 = 10000;
pub const ETH_SPEED_NUM_20G: u32 = 20000;
pub const ETH_SPEED_NUM_25G: u32 = 25000;
pub const ETH_SPEED_NUM_40G: u32 = 40000;
pub const ETH_SPEED_NUM_50G: u32 = 50000;
pub const ETH_SPEED_NUM_56G: u32 = 56000;
pub const ETH_SPEED_NUM_100G: u32 = 100000;
pub const ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const ETH_LINK_DOWN: u32 = 0;
pub const ETH_LINK_UP: u32 = 1;
pub const ETH_LINK_FIXED: u32 = 0;
pub const ETH_LINK_AUTONEG: u32 = 1;
pub const ETH_MQ_RX_RSS_FLAG: u32 = 1;
pub const ETH_MQ_RX_DCB_FLAG: u32 = 2;
pub const ETH_MQ_RX_VMDQ_FLAG: u32 = 4;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_GTPU: u32 = 23;
pub const RTE_ETH_FLOW_MAX: u32 = 24;
pub const ETH_RSS_IPV4: u32 = 4;
pub const ETH_RSS_FRAG_IPV4: u32 = 8;
pub const ETH_RSS_NONFRAG_IPV4_TCP: u32 = 16;
pub const ETH_RSS_NONFRAG_IPV4_UDP: u32 = 32;
pub const ETH_RSS_NONFRAG_IPV4_SCTP: u32 = 64;
pub const ETH_RSS_NONFRAG_IPV4_OTHER: u32 = 128;
pub const ETH_RSS_IPV6: u32 = 256;
pub const ETH_RSS_FRAG_IPV6: u32 = 512;
pub const ETH_RSS_NONFRAG_IPV6_TCP: u32 = 1024;
pub const ETH_RSS_NONFRAG_IPV6_UDP: u32 = 2048;
pub const ETH_RSS_NONFRAG_IPV6_SCTP: u32 = 4096;
pub const ETH_RSS_NONFRAG_IPV6_OTHER: u32 = 8192;
pub const ETH_RSS_L2_PAYLOAD: u32 = 16384;
pub const ETH_RSS_IPV6_EX: u32 = 32768;
pub const ETH_RSS_IPV6_TCP_EX: u32 = 65536;
pub const ETH_RSS_IPV6_UDP_EX: u32 = 131072;
pub const ETH_RSS_PORT: u32 = 262144;
pub const ETH_RSS_VXLAN: u32 = 524288;
pub const ETH_RSS_GENEVE: u32 = 1048576;
pub const ETH_RSS_NVGRE: u32 = 2097152;
pub const ETH_RSS_GTPU: u32 = 8388608;
pub const ETH_RSS_L3_SRC_ONLY: i64 = -9223372036854775808;
pub const ETH_RSS_L3_DST_ONLY: u64 = 4611686018427387904;
pub const ETH_RSS_L4_SRC_ONLY: u64 = 2305843009213693952;
pub const ETH_RSS_L4_DST_ONLY: u64 = 1152921504606846976;
pub const ETH_RSS_IP: u32 = 41868;
pub const ETH_RSS_UDP: u32 = 133152;
pub const ETH_RSS_TCP: u32 = 66576;
pub const ETH_RSS_SCTP: u32 = 4160;
pub const ETH_RSS_TUNNEL: u32 = 3670016;
pub const ETH_RSS_PROTO_MASK: u32 = 4194300;
pub const ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_RETA_GROUP_SIZE: u32 = 64;
pub const ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_PG_SUPPORT: u32 = 1;
pub const ETH_DCB_PFC_SUPPORT: u32 = 2;
pub const ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const ETH_QINQ_STRIP_OFFLOAD: u32 = 8;
pub const ETH_VLAN_STRIP_MASK: u32 = 1;
pub const ETH_VLAN_FILTER_MASK: u32 = 2;
pub const ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const ETH_QINQ_STRIP_MASK: u32 = 8;
pub const ETH_VLAN_ID_MAX: u32 = 4095;
pub const ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const ETH_VMDQ_ACCEPT_UNTAG: u32 = 1;
pub const ETH_VMDQ_ACCEPT_HASH_MC: u32 = 2;
pub const ETH_VMDQ_ACCEPT_HASH_UC: u32 = 4;
pub const ETH_VMDQ_ACCEPT_BROADCAST: u32 = 8;
pub const ETH_VMDQ_ACCEPT_MULTICAST: u32 = 16;
pub const ETH_MIRROR_MAX_VLANS: u32 = 64;
pub const ETH_MIRROR_VIRTUAL_POOL_UP: u32 = 1;
pub const ETH_MIRROR_UPLINK_PORT: u32 = 2;
pub const ETH_MIRROR_DOWNLINK_PORT: u32 = 4;
pub const ETH_MIRROR_VLAN: u32 = 8;
pub const ETH_MIRROR_VIRTUAL_POOL_DOWN: u32 = 16;
pub const RTE_ETH_MAX_HAIRPIN_PEERS: u32 = 32;
pub const RTE_ARP_HRD_ETHER: u32 = 1;
pub const RTE_ARP_OP_REQUEST: u32 = 1;
pub const RTE_ARP_OP_REPLY: u32 = 2;
pub const RTE_ARP_OP_REVREQUEST: u32 = 3;
pub const RTE_ARP_OP_REVREPLY: u32 = 4;
pub const RTE_ARP_OP_INVREQUEST: u32 = 8;
pub const RTE_ARP_OP_INVREPLY: u32 = 9;
pub const RTE_IP_ICMP_ECHO_REPLY: u32 = 0;
pub const RTE_IP_ICMP_ECHO_REQUEST: u32 = 8;
pub const RTE_IPV4_MAX_PKT_LEN: u32 = 65535;
pub const RTE_IPV4_HDR_IHL_MASK: u32 = 15;
pub const RTE_IPV4_IHL_MULTIPLIER: u32 = 4;
pub const RTE_IPV4_HDR_DSCP_MASK: u32 = 252;
pub const RTE_IPV4_HDR_ECN_MASK: u32 = 3;
pub const RTE_IPV4_HDR_ECN_CE: u32 = 3;
pub const RTE_IPV4_HDR_DF_SHIFT: u32 = 14;
pub const RTE_IPV4_HDR_MF_SHIFT: u32 = 13;
pub const RTE_IPV4_HDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV4_HDR_DF_FLAG: u32 = 16384;
pub const RTE_IPV4_HDR_MF_FLAG: u32 = 8192;
pub const RTE_IPV4_HDR_OFFSET_MASK: u32 = 8191;
pub const RTE_IPV4_HDR_OFFSET_UNITS: u32 = 8;
pub const RTE_IPV4_MIN_IHL: u32 = 5;
pub const RTE_IPV4_VHL_DEF: u32 = 69;
pub const RTE_IPV6_HDR_FL_SHIFT: u32 = 0;
pub const RTE_IPV6_HDR_TC_SHIFT: u32 = 20;
pub const RTE_IPV6_HDR_FL_MASK: u32 = 1048575;
pub const RTE_IPV6_HDR_TC_MASK: u32 = 267386880;
pub const RTE_IPV6_HDR_DSCP_MASK: u32 = 264241152;
pub const RTE_IPV6_HDR_ECN_MASK: u32 = 3145728;
pub const RTE_IPV6_HDR_ECN_CE: u32 = 3145728;
pub const RTE_IPV6_FRAG_HDR_SIZE: u32 = 8;
pub const RTE_TCP_CWR_FLAG: u32 = 128;
pub const RTE_TCP_ECE_FLAG: u32 = 64;
pub const RTE_TCP_URG_FLAG: u32 = 32;
pub const RTE_TCP_ACK_FLAG: u32 = 16;
pub const RTE_TCP_PSH_FLAG: u32 = 8;
pub const RTE_TCP_RST_FLAG: u32 = 4;
pub const RTE_TCP_SYN_FLAG: u32 = 2;
pub const RTE_TCP_FIN_FLAG: u32 = 1;
pub const RTE_MBUF_DYN_NAMESIZE: u32 = 64;
pub const RTE_MBUF_DYNFIELD_METADATA_NAME: &'static [u8; 27usize] = b"rte_flow_dynfield_metadata\0";
pub const RTE_MBUF_DYNFLAG_METADATA_NAME: &'static [u8; 26usize] = b"rte_flow_dynflag_metadata\0";
pub const RTE_ETHTYPE_FLAGS_MAC: u32 = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: u32 = 2;
pub const RTE_FLEX_FILTER_MAXLEN: u32 = 128;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const RTE_NTUPLE_TCP_FLAGS_MASK: u32 = 63;
pub const ETH_TUNNEL_FILTER_OMAC: u32 = 1;
pub const ETH_TUNNEL_FILTER_OIP: u32 = 2;
pub const ETH_TUNNEL_FILTER_TENID: u32 = 4;
pub const ETH_TUNNEL_FILTER_IMAC: u32 = 8;
pub const ETH_TUNNEL_FILTER_IVLAN: u32 = 16;
pub const ETH_TUNNEL_FILTER_IIP: u32 = 32;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN: u32 = 24;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID: u32 = 28;
pub const RTE_TUNNEL_FILTER_IMAC_TENID: u32 = 12;
pub const RTE_TUNNEL_FILTER_OMAC_TENID_IMAC: u32 = 13;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const DEV_RX_OFFLOAD_VLAN_STRIP: u32 = 1;
pub const DEV_RX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_RX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_RX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_RX_OFFLOAD_TCP_LRO: u32 = 16;
pub const DEV_RX_OFFLOAD_QINQ_STRIP: u32 = 32;
pub const DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 64;
pub const DEV_RX_OFFLOAD_MACSEC_STRIP: u32 = 128;
pub const DEV_RX_OFFLOAD_HEADER_SPLIT: u32 = 256;
pub const DEV_RX_OFFLOAD_VLAN_FILTER: u32 = 512;
pub const DEV_RX_OFFLOAD_VLAN_EXTEND: u32 = 1024;
pub const DEV_RX_OFFLOAD_JUMBO_FRAME: u32 = 2048;
pub const DEV_RX_OFFLOAD_SCATTER: u32 = 8192;
pub const DEV_RX_OFFLOAD_TIMESTAMP: u32 = 16384;
pub const DEV_RX_OFFLOAD_SECURITY: u32 = 32768;
pub const DEV_RX_OFFLOAD_KEEP_CRC: u32 = 65536;
pub const DEV_RX_OFFLOAD_SCTP_CKSUM: u32 = 131072;
pub const DEV_RX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 262144;
pub const DEV_RX_OFFLOAD_RSS_HASH: u32 = 524288;
pub const DEV_RX_OFFLOAD_CHECKSUM: u32 = 14;
pub const DEV_RX_OFFLOAD_VLAN: u32 = 1569;
pub const DEV_TX_OFFLOAD_VLAN_INSERT: u32 = 1;
pub const DEV_TX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_TX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_TX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_TX_OFFLOAD_SCTP_CKSUM: u32 = 16;
pub const DEV_TX_OFFLOAD_TCP_TSO: u32 = 32;
pub const DEV_TX_OFFLOAD_UDP_TSO: u32 = 64;
pub const DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 128;
pub const DEV_TX_OFFLOAD_QINQ_INSERT: u32 = 256;
pub const DEV_TX_OFFLOAD_VXLAN_TNL_TSO: u32 = 512;
pub const DEV_TX_OFFLOAD_GRE_TNL_TSO: u32 = 1024;
pub const DEV_TX_OFFLOAD_IPIP_TNL_TSO: u32 = 2048;
pub const DEV_TX_OFFLOAD_GENEVE_TNL_TSO: u32 = 4096;
pub const DEV_TX_OFFLOAD_MACSEC_INSERT: u32 = 8192;
pub const DEV_TX_OFFLOAD_MT_LOCKFREE: u32 = 16384;
pub const DEV_TX_OFFLOAD_MULTI_SEGS: u32 = 32768;
pub const DEV_TX_OFFLOAD_MBUF_FAST_FREE: u32 = 65536;
pub const DEV_TX_OFFLOAD_SECURITY: u32 = 131072;
pub const DEV_TX_OFFLOAD_UDP_TNL_TSO: u32 = 262144;
pub const DEV_TX_OFFLOAD_IP_TNL_TSO: u32 = 524288;
pub const DEV_TX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 1048576;
pub const RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP: u32 = 1;
pub const RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP: u32 = 2;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 65535;
pub const RTE_ETH_BURST_FLAG_PER_QUEUE: u32 = 1;
pub const RTE_ETH_BURST_MODE_INFO_SIZE: u32 = 1024;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const ETH_DCB_NUM_TCS: u32 = 8;
pub const ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_ALL: u32 = 32;
pub const ETH_L2_TUNNEL_ENABLE_MASK: u32 = 1;
pub const ETH_L2_TUNNEL_INSERTION_MASK: u32 = 2;
pub const ETH_L2_TUNNEL_STRIPPING_MASK: u32 = 4;
pub const ETH_L2_TUNNEL_FORWARDING_MASK: u32 = 8;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 64;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_DEV_CLOSE_REMOVE: u32 = 1;
pub const RTE_ETH_DEV_INTR_LSC: u32 = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: u32 = 4;
pub const RTE_ETH_DEV_INTR_RMV: u32 = 8;
pub const RTE_ETH_DEV_REPRESENTOR: u32 = 16;
pub const RTE_ETH_DEV_NOLIVE_MAC_ADDR: u32 = 32;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub const RTE_CLASS_ANY_ID: u32 = 16777215;
pub const RTE_KNI_NAMESIZE: u32 = 16;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type va_list = __builtin_va_list;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ssize_t = __ssize_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rte_cpuset_t = cpu_set_t;
pub type phys_addr_t = u64;
pub type rte_iova_t = u64;
extern "C" {
    pub fn rte_exit(exit_code: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_log_dynamic_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_logs {
    pub type_: u32,
    pub level: u32,
    pub file: *mut FILE,
    pub dynamic_types_len: size_t,
    pub dynamic_types: *mut rte_log_dynamic_type,
}
#[test]
fn bindgen_test_layout_rte_logs() {
    assert_eq!(
        ::std::mem::size_of::<rte_logs>(),
        32usize,
        concat!("Size of: ", stringify!(rte_logs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_logs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_logs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types)
        )
    );
}
impl Default for rte_logs {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut rte_logs: rte_logs;
}
extern "C" {
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_get_stream() -> *mut FILE;
}
extern "C" {
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_dev_event_type {
    pub type Type = u32;
    pub const RTE_DEV_EVENT_ADD: Type = 0;
    pub const RTE_DEV_EVENT_REMOVE: Type = 1;
    pub const RTE_DEV_EVENT_MAX: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_event {
    pub type_: rte_dev_event_type::Type,
    pub subsystem: ::std::os::raw::c_int,
    pub devname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_dev_event() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_event>(),
        16usize,
        concat!("Size of: ", stringify!(rte_dev_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).subsystem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).devname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(devname)
        )
    );
}
impl Default for rte_dev_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_dev_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type::Type,
        cb_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub mod rte_kernel_driver {
    pub type Type = u32;
    pub const RTE_KDRV_UNKNOWN: Type = 0;
    pub const RTE_KDRV_IGB_UIO: Type = 1;
    pub const RTE_KDRV_VFIO: Type = 2;
    pub const RTE_KDRV_UIO_GENERIC: Type = 3;
    pub const RTE_KDRV_NIC_UIO: Type = 4;
    pub const RTE_KDRV_NONE: Type = 5;
}
pub mod rte_dev_policy {
    pub type Type = u32;
    pub const RTE_DEV_WHITELISTED: Type = 0;
    pub const RTE_DEV_BLACKLISTED: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mem_resource {
    pub phys_addr: u64,
    pub len: u64,
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_mem_resource() {
    assert_eq!(
        ::std::mem::size_of::<rte_mem_resource>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mem_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).phys_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for rte_mem_resource {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_driver {
    pub next: rte_driver__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[test]
fn bindgen_test_layout_rte_driver__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_driver__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_driver() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver>(),
        32usize,
        concat!("Size of: ", stringify!(rte_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).alias as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for rte_driver {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_device {
    pub next: rte_device__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub driver: *const rte_driver,
    pub bus: *const rte_bus,
    pub numa_node: ::std::os::raw::c_int,
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[test]
fn bindgen_test_layout_rte_device__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_device__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_device__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_device() {
    assert_eq!(
        ::std::mem::size_of::<rte_device>(),
        56usize,
        concat!("Size of: ", stringify!(rte_device))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).driver as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).bus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).numa_node as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).devargs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(devargs)
        )
    );
}
impl Default for rte_device {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_dev_is_probed(dev: *const rte_device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        drvargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_probe(devargs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_remove(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_device,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_iterator {
    pub dev_str: *const ::std::os::raw::c_char,
    pub bus_str: *const ::std::os::raw::c_char,
    pub cls_str: *const ::std::os::raw::c_char,
    pub bus: *mut rte_bus,
    pub cls: *mut rte_class,
    pub device: *mut rte_device,
    pub class_device: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_dev_iterator() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_iterator>(),
        56usize,
        concat!("Size of: ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).dev_str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(dev_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus_str as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(bus_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls_str as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(cls_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).class_device as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(class_device)
        )
    );
}
impl Default for rte_dev_iterator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_dev_iterate_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const ::std::os::raw::c_void,
        devstr: *const ::std::os::raw::c_char,
        it: *const rte_dev_iterator,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn rte_dev_iterator_init(
        it: *mut rte_dev_iterator,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_iterator_next(it: *mut rte_dev_iterator) -> *mut rte_device;
}
extern "C" {
    pub fn rte_dev_event_callback_register(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_event_callback_unregister(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_event_callback_process(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type::Type,
    );
}
extern "C" {
    pub fn rte_dev_event_monitor_start() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_event_monitor_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_hotplug_handle_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_hotplug_handle_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_dma_map(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_dma_unmap(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for rte_bus_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_iova_mode {
    pub type Type = u32;
    pub const RTE_IOVA_DC: Type = 0;
    pub const RTE_IOVA_PA: Type = 1;
    pub const RTE_IOVA_VA: Type = 2;
}
pub type rte_bus_scan_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type rte_bus_probe_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type rte_bus_find_device_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const rte_device,
        cmp: rte_dev_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_device,
>;
pub type rte_bus_plug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_unplug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_parse_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_dev_dma_map_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_dev_dma_unmap_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_bus_hot_unplug_handler_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_sigbus_handler_t = ::std::option::Option<
    unsafe extern "C" fn(failure_addr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub mod rte_bus_scan_mode {
    pub type Type = u32;
    pub const RTE_BUS_SCAN_UNDEFINED: Type = 0;
    pub const RTE_BUS_SCAN_WHITELIST: Type = 1;
    pub const RTE_BUS_SCAN_BLACKLIST: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus_conf {
    pub scan_mode: rte_bus_scan_mode::Type,
}
#[test]
fn bindgen_test_layout_rte_bus_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_conf>())).scan_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_conf),
            "::",
            stringify!(scan_mode)
        )
    );
}
impl Default for rte_bus_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_bus_get_iommu_class_t =
    ::std::option::Option<unsafe extern "C" fn() -> rte_iova_mode::Type>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus {
    pub next: rte_bus__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub scan: rte_bus_scan_t,
    pub probe: rte_bus_probe_t,
    pub find_device: rte_bus_find_device_t,
    pub plug: rte_bus_plug_t,
    pub unplug: rte_bus_unplug_t,
    pub parse: rte_bus_parse_t,
    pub dma_map: rte_dev_dma_map_t,
    pub dma_unmap: rte_dev_dma_unmap_t,
    pub conf: rte_bus_conf,
    pub get_iommu_class: rte_bus_get_iommu_class_t,
    pub dev_iterate: rte_dev_iterate_t,
    pub hot_unplug_handler: rte_bus_hot_unplug_handler_t,
    pub sigbus_handler: rte_bus_sigbus_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_bus__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_bus() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus>(),
        128usize,
        concat!("Size of: ", stringify!(rte_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).scan as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).probe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).find_device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(find_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).plug as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).unplug as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(unplug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).parse as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dma_map as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(dma_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dma_unmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(dma_unmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).conf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).get_iommu_class as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(get_iommu_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dev_iterate as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(dev_iterate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).hot_unplug_handler as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(hot_unplug_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).sigbus_handler as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(sigbus_handler)
        )
    );
}
impl Default for rte_bus {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_bus_register(bus: *mut rte_bus);
}
extern "C" {
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
extern "C" {
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_bus_dump(f: *mut FILE);
}
pub type rte_bus_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *const rte_bus,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_bus_find(
        start: *const rte_bus,
        cmp: rte_bus_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_bus;
}
extern "C" {
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
extern "C" {
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char) -> *mut rte_bus;
}
extern "C" {
    pub fn rte_bus_get_iommu_class() -> rte_iova_mode::Type;
}
pub mod rte_intr_mode {
    pub type Type = u32;
    pub const RTE_INTR_MODE_NONE: Type = 0;
    pub const RTE_INTR_MODE_LEGACY: Type = 1;
    pub const RTE_INTR_MODE_MSI: Type = 2;
    pub const RTE_INTR_MODE_MSIX: Type = 3;
}
pub mod rte_lcore_role_t {
    pub type Type = u32;
    pub const ROLE_RTE: Type = 0;
    pub const ROLE_OFF: Type = 1;
    pub const ROLE_SERVICE: Type = 2;
}
pub mod rte_proc_type_t {
    pub type Type = i32;
    pub const RTE_PROC_AUTO: Type = -1;
    pub const RTE_PROC_PRIMARY: Type = 0;
    pub const RTE_PROC_SECONDARY: Type = 1;
    pub const RTE_PROC_INVALID: Type = 2;
}
extern "C" {
    pub fn rte_eal_process_type() -> rte_proc_type_t::Type;
}
extern "C" {
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_rte_mp_msg() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_msg>(),
        360usize,
        concat!("Size of: ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).len_param as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(len_param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).num_fds as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(num_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).param as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).fds as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(fds)
        )
    );
}
impl Default for rte_mp_msg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[test]
fn bindgen_test_layout_rte_mp_reply() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_reply>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_reply>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_sent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_received as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_received)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(msgs)
        )
    );
}
impl Default for rte_mp_reply {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const rte_mp_msg,
        reply: *const rte_mp_reply,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_mp_action_register(
        name: *const ::std::os::raw::c_char,
        action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_action_unregister(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rte_mp_sendmsg(msg: *mut rte_mp_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_request_sync(
        req: *mut rte_mp_msg,
        reply: *mut rte_mp_reply,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_request_async(
        req: *mut rte_mp_msg,
        ts: *const timespec,
        clb: rte_mp_async_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_reply(
        msg: *mut rte_mp_msg,
        peer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
extern "C" {
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode::Type;
}
extern "C" {
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_iova_mode() -> rte_iova_mode::Type;
}
extern "C" {
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub mod _bindgen_ty_12 {
    pub type Type = u32;
    pub const RTE_MIN_ERRNO: Type = 1000;
    pub const E_RTE_SECONDARY: Type = 1001;
    pub const E_RTE_NO_CONFIG: Type = 1002;
    pub const RTE_MAX_ERRNO: Type = 1003;
}
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
pub type rte_intr_unregister_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(intr_handle: *mut rte_intr_handle, cb_arg: *mut ::std::os::raw::c_void),
>;
pub mod rte_intr_handle_type {
    pub type Type = u32;
    pub const RTE_INTR_HANDLE_UNKNOWN: Type = 0;
    pub const RTE_INTR_HANDLE_UIO: Type = 1;
    pub const RTE_INTR_HANDLE_UIO_INTX: Type = 2;
    pub const RTE_INTR_HANDLE_VFIO_LEGACY: Type = 3;
    pub const RTE_INTR_HANDLE_VFIO_MSI: Type = 4;
    pub const RTE_INTR_HANDLE_VFIO_MSIX: Type = 5;
    pub const RTE_INTR_HANDLE_ALARM: Type = 6;
    pub const RTE_INTR_HANDLE_EXT: Type = 7;
    pub const RTE_INTR_HANDLE_VDEV: Type = 8;
    pub const RTE_INTR_HANDLE_DEV_EVENT: Type = 9;
    pub const RTE_INTR_HANDLE_VFIO_REQ: Type = 10;
    pub const RTE_INTR_HANDLE_MAX: Type = 11;
}
pub type rte_intr_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(fd: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_epoll_data {
    pub event: u32,
    pub data: *mut ::std::os::raw::c_void,
    pub cb_fun: rte_intr_event_cb_t,
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_epoll_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_data>(),
        32usize,
        concat!("Size of: ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_data>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_fun as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_fun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_arg)
        )
    );
}
impl Default for rte_epoll_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_13 {
    pub type Type = u32;
    pub const RTE_EPOLL_INVALID: Type = 0;
    pub const RTE_EPOLL_VALID: Type = 1;
    pub const RTE_EPOLL_EXEC: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_epoll_event {
    pub status: u32,
    pub fd: ::std::os::raw::c_int,
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
#[test]
fn bindgen_test_layout_rte_epoll_event() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_event>(),
        48usize,
        concat!("Size of: ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(epfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(epdata)
        )
    );
}
impl Default for rte_epoll_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    pub fd: ::std::os::raw::c_int,
    pub type_: rte_intr_handle_type::Type,
    pub max_intr: u32,
    pub nb_efd: u32,
    pub efd_counter_size: u8,
    pub efds: [::std::os::raw::c_int; 512usize],
    pub elist: [rte_epoll_event; 512usize],
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_intr_handle__bindgen_ty_1 {
    pub vfio_dev_fd: ::std::os::raw::c_int,
    pub uio_cfg_fd: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1>())).vfio_dev_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1),
            "::",
            stringify!(vfio_dev_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1>())).uio_cfg_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1),
            "::",
            stringify!(uio_cfg_fd)
        )
    );
}
impl Default for rte_intr_handle__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_intr_handle() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle>(),
        26656usize,
        concat!("Size of: ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).max_intr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(max_intr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).nb_efd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(nb_efd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle>())).efd_counter_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(efd_counter_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).efds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(efds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).elist as *const _ as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(elist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).intr_vec as *const _ as usize },
        26648usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(intr_vec)
        )
    );
}
impl Default for rte_intr_handle {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_epoll_wait(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_epoll_ctl(
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        event: *mut rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_rx_ctl(
        intr_handle: *mut rte_intr_handle,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    pub fn rte_intr_efd_enable(
        intr_handle: *mut rte_intr_handle,
        nb_efd: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_callback_register(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_callback_unregister(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_callback_unregister_pending(
        intr_handle: *const rte_intr_handle,
        cb_fn: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
        ucb_fn: rte_intr_unregister_callback_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_intr_ack(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
pub mod rte_devtype {
    pub type Type = u32;
    pub const RTE_DEVTYPE_WHITELISTED_PCI: Type = 0;
    pub const RTE_DEVTYPE_BLACKLISTED_PCI: Type = 1;
    pub const RTE_DEVTYPE_VIRTUAL: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    pub next: rte_devargs__bindgen_ty_1,
    pub type_: rte_devtype::Type,
    pub policy: rte_dev_policy::Type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    pub bus: *mut rte_bus,
    pub cls: *mut rte_class,
    pub bus_str: *const ::std::os::raw::c_char,
    pub cls_str: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_devargs__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    pub args: *mut ::std::os::raw::c_char,
    pub drv_str: *const ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_devargs__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs__bindgen_ty_2>())).args as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_2),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_2>())).drv_str as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_2),
            "::",
            stringify!(drv_str)
        )
    );
}
impl Default for rte_devargs__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_devargs() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs>(),
        136usize,
        concat!("Size of: ", stringify!(rte_devargs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).policy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).bus as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).cls as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).bus_str as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(bus_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).cls_str as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(cls_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).data as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(data)
        )
    );
}
impl Default for rte_devargs {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_devargs_parse(
        da: *mut rte_devargs,
        dev: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_devargs_parsef(
        da: *mut rte_devargs,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_devargs_insert(da: *mut *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_devargs_add(
        devtype: rte_devtype::Type,
        devargs_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_devargs_remove(devargs: *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_devargs_type_count(devtype: rte_devtype::Type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_devargs_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_devargs_next(
        busname: *const ::std::os::raw::c_char,
        start: *const rte_devargs,
    ) -> *mut rte_devargs;
}
pub type rte_v64u8_t = [u8; 8usize];
pub type rte_v64u16_t = [u16; 4usize];
pub type rte_v64u32_t = [u32; 2usize];
pub type rte_v128u8_t = [u8; 16usize];
pub type rte_v128u16_t = [u16; 8usize];
pub type rte_v128u32_t = [u32; 4usize];
pub type rte_v128u64_t = [u64; 2usize];
pub type rte_v256u8_t = [u8; 32usize];
pub type rte_v256u16_t = [u16; 16usize];
pub type rte_v256u32_t = [u32; 8usize];
pub type rte_v256u64_t = [u64; 4usize];
pub type rte_v64s8_t = [i8; 8usize];
pub type rte_v64s16_t = [i16; 4usize];
pub type rte_v64s32_t = [i32; 2usize];
pub type rte_v128s8_t = [i8; 16usize];
pub type rte_v128s16_t = [i16; 8usize];
pub type rte_v128s32_t = [i32; 4usize];
pub type rte_v128s64_t = [i64; 2usize];
pub type rte_v256s8_t = [i8; 32usize];
pub type rte_v256s16_t = [i16; 16usize];
pub type rte_v256s32_t = [i32; 8usize];
pub type rte_v256s64_t = [i64; 4usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8: [u8; 16usize],
    pub u16: [u16; 8usize],
    pub u32: [u32; 4usize],
    pub u64: [u64; 2usize],
    pub pd: [f64; 2usize],
    _bindgen_union_align: u128,
}
#[test]
fn bindgen_test_layout_rte_xmm() {
    assert_eq!(
        ::std::mem::size_of::<rte_xmm>(),
        16usize,
        concat!("Size of: ", stringify!(rte_xmm))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_xmm>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_xmm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(pd)
        )
    );
}
impl Default for rte_xmm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_xmm_t = rte_xmm;
pub type ymm_t = __m256i;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub union rte_ymm {
    pub y: ymm_t,
    pub x: [xmm_t; 2usize],
    pub u8: [u8; 32usize],
    pub u16: [u16; 16usize],
    pub u32: [u32; 8usize],
    pub u64: [u64; 4usize],
    pub pd: [f64; 4usize],
    _bindgen_union_align: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rte_ymm() {
    assert_eq!(
        ::std::mem::size_of::<rte_ymm>(),
        32usize,
        concat!("Size of: ", stringify!(rte_ymm))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ymm>(),
        32usize,
        concat!("Alignment of ", stringify!(rte_ymm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).y as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(pd)
        )
    );
}
impl Default for rte_ymm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_ymm_t = rte_ymm;
extern "C" {
    pub fn rte_srand(seedval: u64);
}
extern "C" {
    pub fn rte_rand() -> u64;
}
extern "C" {
    pub fn rte_rand_max(upper_bound: u64) -> u64;
}
pub mod rte_lcore_state_t {
    pub type Type = u32;
    pub const WAIT: Type = 0;
    pub const RUNNING: Type = 1;
    pub const FINISHED: Type = 2;
}
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        slave_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_rmt_call_master_t {
    pub type Type = u32;
    pub const SKIP_MASTER: Type = 0;
    pub const CALL_MASTER: Type = 1;
}
extern "C" {
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_master: rte_rmt_call_master_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_get_lcore_state(slave_id: ::std::os::raw::c_uint) -> rte_lcore_state_t::Type;
}
extern "C" {
    pub fn rte_eal_wait_lcore(slave_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_mp_wait_lcore();
}
extern "C" {
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t::Type;
}
extern "C" {
    pub fn rte_get_master_lcore() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_index(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_to_socket_id(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_to_cpu_id(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_cpuset(lcore_id: ::std::os::raw::c_uint) -> rte_cpuset_t;
}
extern "C" {
    pub fn rte_lcore_is_enabled(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_master: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
extern "C" {
    pub fn rte_thread_setname(
        id: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_ctrl_thread_create(
        thread: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        attr: *const pthread_attr_t,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_has_role(
        lcore_id: ::std::os::raw::c_uint,
        role: rte_lcore_role_t::Type,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_spinlock_t {
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_t>())).locked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_t),
            "::",
            stringify!(locked)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_spinlock_recursive_t {
    pub sl: rte_spinlock_t,
    pub user: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_recursive_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_recursive_t>(),
        12usize,
        concat!("Size of: ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_recursive_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).user as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(count)
        )
    );
}
pub mod rte_cpu_flag_t {
    pub type Type = u32;
    pub const RTE_CPUFLAG_SSE3: Type = 0;
    pub const RTE_CPUFLAG_PCLMULQDQ: Type = 1;
    pub const RTE_CPUFLAG_DTES64: Type = 2;
    pub const RTE_CPUFLAG_MONITOR: Type = 3;
    pub const RTE_CPUFLAG_DS_CPL: Type = 4;
    pub const RTE_CPUFLAG_VMX: Type = 5;
    pub const RTE_CPUFLAG_SMX: Type = 6;
    pub const RTE_CPUFLAG_EIST: Type = 7;
    pub const RTE_CPUFLAG_TM2: Type = 8;
    pub const RTE_CPUFLAG_SSSE3: Type = 9;
    pub const RTE_CPUFLAG_CNXT_ID: Type = 10;
    pub const RTE_CPUFLAG_FMA: Type = 11;
    pub const RTE_CPUFLAG_CMPXCHG16B: Type = 12;
    pub const RTE_CPUFLAG_XTPR: Type = 13;
    pub const RTE_CPUFLAG_PDCM: Type = 14;
    pub const RTE_CPUFLAG_PCID: Type = 15;
    pub const RTE_CPUFLAG_DCA: Type = 16;
    pub const RTE_CPUFLAG_SSE4_1: Type = 17;
    pub const RTE_CPUFLAG_SSE4_2: Type = 18;
    pub const RTE_CPUFLAG_X2APIC: Type = 19;
    pub const RTE_CPUFLAG_MOVBE: Type = 20;
    pub const RTE_CPUFLAG_POPCNT: Type = 21;
    pub const RTE_CPUFLAG_TSC_DEADLINE: Type = 22;
    pub const RTE_CPUFLAG_AES: Type = 23;
    pub const RTE_CPUFLAG_XSAVE: Type = 24;
    pub const RTE_CPUFLAG_OSXSAVE: Type = 25;
    pub const RTE_CPUFLAG_AVX: Type = 26;
    pub const RTE_CPUFLAG_F16C: Type = 27;
    pub const RTE_CPUFLAG_RDRAND: Type = 28;
    pub const RTE_CPUFLAG_HYPERVISOR: Type = 29;
    pub const RTE_CPUFLAG_FPU: Type = 30;
    pub const RTE_CPUFLAG_VME: Type = 31;
    pub const RTE_CPUFLAG_DE: Type = 32;
    pub const RTE_CPUFLAG_PSE: Type = 33;
    pub const RTE_CPUFLAG_TSC: Type = 34;
    pub const RTE_CPUFLAG_MSR: Type = 35;
    pub const RTE_CPUFLAG_PAE: Type = 36;
    pub const RTE_CPUFLAG_MCE: Type = 37;
    pub const RTE_CPUFLAG_CX8: Type = 38;
    pub const RTE_CPUFLAG_APIC: Type = 39;
    pub const RTE_CPUFLAG_SEP: Type = 40;
    pub const RTE_CPUFLAG_MTRR: Type = 41;
    pub const RTE_CPUFLAG_PGE: Type = 42;
    pub const RTE_CPUFLAG_MCA: Type = 43;
    pub const RTE_CPUFLAG_CMOV: Type = 44;
    pub const RTE_CPUFLAG_PAT: Type = 45;
    pub const RTE_CPUFLAG_PSE36: Type = 46;
    pub const RTE_CPUFLAG_PSN: Type = 47;
    pub const RTE_CPUFLAG_CLFSH: Type = 48;
    pub const RTE_CPUFLAG_DS: Type = 49;
    pub const RTE_CPUFLAG_ACPI: Type = 50;
    pub const RTE_CPUFLAG_MMX: Type = 51;
    pub const RTE_CPUFLAG_FXSR: Type = 52;
    pub const RTE_CPUFLAG_SSE: Type = 53;
    pub const RTE_CPUFLAG_SSE2: Type = 54;
    pub const RTE_CPUFLAG_SS: Type = 55;
    pub const RTE_CPUFLAG_HTT: Type = 56;
    pub const RTE_CPUFLAG_TM: Type = 57;
    pub const RTE_CPUFLAG_PBE: Type = 58;
    pub const RTE_CPUFLAG_DIGTEMP: Type = 59;
    pub const RTE_CPUFLAG_TRBOBST: Type = 60;
    pub const RTE_CPUFLAG_ARAT: Type = 61;
    pub const RTE_CPUFLAG_PLN: Type = 62;
    pub const RTE_CPUFLAG_ECMD: Type = 63;
    pub const RTE_CPUFLAG_PTM: Type = 64;
    pub const RTE_CPUFLAG_MPERF_APERF_MSR: Type = 65;
    pub const RTE_CPUFLAG_ACNT2: Type = 66;
    pub const RTE_CPUFLAG_ENERGY_EFF: Type = 67;
    pub const RTE_CPUFLAG_FSGSBASE: Type = 68;
    pub const RTE_CPUFLAG_BMI1: Type = 69;
    pub const RTE_CPUFLAG_HLE: Type = 70;
    pub const RTE_CPUFLAG_AVX2: Type = 71;
    pub const RTE_CPUFLAG_SMEP: Type = 72;
    pub const RTE_CPUFLAG_BMI2: Type = 73;
    pub const RTE_CPUFLAG_ERMS: Type = 74;
    pub const RTE_CPUFLAG_INVPCID: Type = 75;
    pub const RTE_CPUFLAG_RTM: Type = 76;
    pub const RTE_CPUFLAG_AVX512F: Type = 77;
    pub const RTE_CPUFLAG_RDSEED: Type = 78;
    pub const RTE_CPUFLAG_LAHF_SAHF: Type = 79;
    pub const RTE_CPUFLAG_LZCNT: Type = 80;
    pub const RTE_CPUFLAG_SYSCALL: Type = 81;
    pub const RTE_CPUFLAG_XD: Type = 82;
    pub const RTE_CPUFLAG_1GB_PG: Type = 83;
    pub const RTE_CPUFLAG_RDTSCP: Type = 84;
    pub const RTE_CPUFLAG_EM64T: Type = 85;
    pub const RTE_CPUFLAG_INVTSC: Type = 86;
    pub const RTE_CPUFLAG_NUMFLAGS: Type = 87;
}
extern "C" {
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dump_stack();
}
extern "C" {
    pub fn rte_dump_registers();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic16_t {
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic16_t>(),
        2usize,
        concat!("Size of: ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic16_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic16_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic32_t {
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_atomic32_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic32_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic32_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic32_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic64_t {
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout_rte_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic64_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic64_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
    _bindgen_union_align: u128,
}
#[test]
fn bindgen_test_layout_rte_int128_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_int128_t__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_int128_t__bindgen_ty_1>())).int128 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(int128)
        )
    );
}
impl Default for rte_int128_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_int128_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t))
    );
}
impl Default for rte_int128_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
extern "C" {
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_rwlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_rwlock_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_rwlock_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    pub name: [::std::os::raw::c_char; 64usize],
    pub count: ::std::os::raw::c_uint,
    pub len: ::std::os::raw::c_uint,
    pub elt_sz: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
    pub rwlock: rte_rwlock_t,
}
#[test]
fn bindgen_test_layout_rte_fbarray() {
    assert_eq!(
        ::std::mem::size_of::<rte_fbarray>(),
        96usize,
        concat!("Size of: ", stringify!(rte_fbarray))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fbarray>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_fbarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).len as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).elt_sz as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(elt_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).rwlock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(rwlock)
        )
    );
}
impl Default for rte_fbarray {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
pub mod rte_page_sizes {
    pub type Type = u64;
    pub const RTE_PGSIZE_4K: Type = 4096;
    pub const RTE_PGSIZE_64K: Type = 65536;
    pub const RTE_PGSIZE_256K: Type = 262144;
    pub const RTE_PGSIZE_2M: Type = 2097152;
    pub const RTE_PGSIZE_16M: Type = 16777216;
    pub const RTE_PGSIZE_256M: Type = 268435456;
    pub const RTE_PGSIZE_512M: Type = 536870912;
    pub const RTE_PGSIZE_1G: Type = 1073741824;
    pub const RTE_PGSIZE_4G: Type = 4294967296;
    pub const RTE_PGSIZE_16G: Type = 17179869184;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memseg__bindgen_ty_2,
    pub len: size_t,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub nchannel: u32,
    pub nrank: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    pub phys_addr: phys_addr_t,
    pub iova: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).phys_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(iova)
        )
    );
}
impl Default for rte_memseg__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_2 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_2>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_2),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg__bindgen_ty_2>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_2),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memseg__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg>(),
        48usize,
        concat!("Size of: ", stringify!(rte_memseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memseg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).hugepage_sz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).socket_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nchannel as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nrank as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nrank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_memseg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    pub page_sz: u64,
    pub socket_id: ::std::os::raw::c_int,
    pub version: u32,
    pub len: size_t,
    pub external: ::std::os::raw::c_uint,
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg_list__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).base_va as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(base_va)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memseg_list__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memseg_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list>(),
        136usize,
        concat!("Size of: ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).page_sz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(page_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).socket_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).external as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).heap as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).memseg_arr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(memseg_arr)
        )
    );
}
impl Default for rte_memseg_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
extern "C" {
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: size_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_memseg_walk(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_contig_walk(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_list_walk(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_walk_thread_unsafe(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_contig_walk_thread_unsafe(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_list_walk_thread_unsafe(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_thread_unsafe(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_offset(
        ms: *const rte_memseg,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_offset_thread_unsafe(
        ms: *const rte_memseg,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_unregister(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_attach(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_detach(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
extern "C" {
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
pub mod rte_mem_event {
    pub type Type = u32;
    pub const RTE_MEM_EVENT_ALLOC: Type = 0;
    pub const RTE_MEM_EVENT_FREE: Type = 1;
}
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event::Type,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(
        socket_id: ::std::os::raw::c_int,
        cur_limit: size_t,
        new_len: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memzone__bindgen_ty_2,
    pub len: size_t,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    pub phys_addr: phys_addr_t,
    pub iova: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).phys_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(iova)
        )
    );
}
impl Default for rte_memzone__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_2 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_2>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_2),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memzone__bindgen_ty_2>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_2),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memzone__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone>(),
        72usize,
        concat!("Size of: ", stringify!(rte_memzone))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memzone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).hugepage_sz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).socket_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).flags as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_memzone {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_memzone_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub mod rte_ring_queue_behavior {
    pub type Type = u32;
    pub const RTE_RING_QUEUE_FIXED: Type = 0;
    pub const RTE_RING_QUEUE_VARIABLE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ring_headtail {
    pub head: u32,
    pub tail: u32,
    pub single: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_headtail() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).single as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(single)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 32usize],
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    pub size: u32,
    pub mask: u32,
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub pad0: ::std::os::raw::c_char,
    pub __bindgen_padding_1: [u32; 15usize],
    pub prod: rte_ring_headtail,
    pub __bindgen_padding_2: [u8; 52usize],
    pub pad1: ::std::os::raw::c_char,
    pub __bindgen_padding_3: [u32; 15usize],
    pub cons: rte_ring_headtail,
    pub __bindgen_padding_4: [u8; 52usize],
    pub pad2: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_ring() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring>(),
        384usize,
        concat!("Size of: ", stringify!(rte_ring))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).memzone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(memzone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).capacity as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad0 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).prod as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(prod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).cons as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(cons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad2 as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad2)
        )
    );
}
impl Default for rte_ring {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> ssize_t;
}
extern "C" {
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    pub fn rte_ring_reset(r: *mut rte_ring);
}
extern "C" {
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    pub size: u32,
    pub flushthresh: u32,
    pub len: u32,
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_cache>(),
        12352usize,
        concat!("Size of: ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_cache>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).flushthresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(flushthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).objs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(objs)
        )
    );
}
impl Default for rte_mempool_cache {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mempool_objsz {
    pub elt_size: u32,
    pub header_size: u32,
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objsz>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objsz>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).elt_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).trailer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).total_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(total_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    pub mp: *mut rte_mempool,
    pub __bindgen_anon_1: rte_mempool_objhdr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
impl Default for rte_mempool_objhdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_objhdr__bindgen_ty_2 {
    pub iova: rte_iova_t,
    pub physaddr: phys_addr_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_2>())).iova as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_2>())).physaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2),
            "::",
            stringify!(physaddr)
        )
    );
}
impl Default for rte_mempool_objhdr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(mp)
        )
    );
}
impl Default for rte_mempool_objhdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
impl Default for rte_mempool_objhdr_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
impl Default for rte_mempool_memhdr_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    pub mp: *mut rte_mempool,
    pub addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_mempool_memhdr__bindgen_ty_2,
    pub len: size_t,
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
impl Default for rte_mempool_memhdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_memhdr__bindgen_ty_2 {
    pub iova: rte_iova_t,
    pub phys_addr: phys_addr_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_2>())).iova as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_2>())).phys_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2),
            "::",
            stringify!(phys_addr)
        )
    );
}
impl Default for rte_mempool_memhdr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr>(),
        56usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).free_cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(opaque)
        )
    );
}
impl Default for rte_mempool_memhdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_info {
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mempool_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_info>())).contig_block_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_info),
            "::",
            stringify!(contig_block_size)
        )
    );
}
impl Default for rte_mempool_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    pub pool_config: *mut ::std::os::raw::c_void,
    pub mz: *const rte_memzone,
    pub flags: ::std::os::raw::c_uint,
    pub socket_id: ::std::os::raw::c_int,
    pub size: u32,
    pub cache_size: u32,
    pub elt_size: u32,
    pub header_size: u32,
    pub trailer_size: u32,
    pub private_data_size: ::std::os::raw::c_uint,
    pub ops_index: i32,
    pub local_cache: *mut rte_mempool_cache,
    pub populated_size: u32,
    pub elt_list: rte_mempool_objhdr_list,
    pub nb_mem_chunks: u32,
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    pub pool_data: *mut ::std::os::raw::c_void,
    pub pool_id: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_id)
        )
    );
}
impl Default for rte_mempool__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool>(),
        192usize,
        concat!("Size of: ", stringify!(rte_mempool))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).pool_config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(pool_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).socket_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).cache_size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).header_size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).trailer_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).private_data_size as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(private_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).ops_index as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(ops_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).local_cache as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(local_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).populated_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(populated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_list as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).nb_mem_chunks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(nb_mem_chunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mem_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mem_list)
        )
    );
}
impl Default for rte_mempool {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rte_mempool_contig_blocks_check_cookies(
        mp: *const rte_mempool,
        first_obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t,
>;
extern "C" {
    pub fn rte_mempool_op_calc_mem_size_helper(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        chunk_reserve: size_t,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rte_mempool_op_calc_mem_size_default(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_mempool_op_populate_helper(
        mp: *mut rte_mempool,
        flags: ::std::os::raw::c_uint,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_op_populate_default(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops {
    pub name: [::std::os::raw::c_char; 32usize],
    pub alloc: rte_mempool_alloc_t,
    pub free: rte_mempool_free_t,
    pub enqueue: rte_mempool_enqueue_t,
    pub dequeue: rte_mempool_dequeue_t,
    pub get_count: rte_mempool_get_count,
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    pub populate: rte_mempool_populate_t,
    pub get_info: rte_mempool_get_info_t,
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).enqueue as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).calc_mem_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(calc_mem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).populate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(populate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_info as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue_contig_blocks as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue_contig_blocks)
        )
    );
}
impl Default for rte_mempool_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops_table {
    pub sl: rte_spinlock_t,
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops_table>(),
        2112usize,
        concat!("Size of: ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops_table>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).num_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(num_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).ops as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for rte_mempool_ops_table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mempool_ops_calc_mem_size(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rte_mempool_ops_populate(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_ops_get_info(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_populate_iova(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        iova: rte_iova_t,
        len: size_t,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: size_t,
        pg_sz: size_t,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_cache_create(
        size: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool_cache;
}
extern "C" {
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    pub fn rte_mempool_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn rte_mempool_get_page_size(
        mp: *mut rte_mempool,
        pg_sz: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
extern "C" {
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
pub type MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type MARKER64 = [u64; 0usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf_sched {
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf_sched() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_sched>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_sched>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).queue_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).traffic_class as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).color as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).reserved as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(reserved)
        )
    );
}
pub mod _bindgen_ty_14 {
    pub type Type = u32;
    pub const RTE_MBUF_L2_LEN_BITS: Type = 7;
    pub const RTE_MBUF_L3_LEN_BITS: Type = 9;
    pub const RTE_MBUF_L4_LEN_BITS: Type = 8;
    pub const RTE_MBUF_TSO_SEGSZ_BITS: Type = 16;
    pub const RTE_MBUF_OUTL3_LEN_BITS: Type = 9;
    pub const RTE_MBUF_OUTL2_LEN_BITS: Type = 7;
    pub const RTE_MBUF_TXOFLD_UNUSED_BITS: Type = 8;
    pub const RTE_MBUF_L2_LEN_OFS: Type = 0;
    pub const RTE_MBUF_L3_LEN_OFS: Type = 7;
    pub const RTE_MBUF_L4_LEN_OFS: Type = 16;
    pub const RTE_MBUF_TSO_SEGSZ_OFS: Type = 24;
    pub const RTE_MBUF_OUTL3_LEN_OFS: Type = 40;
    pub const RTE_MBUF_OUTL2_LEN_OFS: Type = 49;
    pub const RTE_MBUF_TXOFLD_UNUSED_OFS: Type = 56;
}
#[repr(C)]
#[repr(align(64))]
pub struct rte_mbuf {
    pub cacheline0: MARKER,
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    pub rearm_data: MARKER64,
    pub data_off: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    pub nb_segs: u16,
    pub port: u16,
    pub ol_flags: u64,
    pub rx_descriptor_fields1: MARKER,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    pub pkt_len: u32,
    pub data_len: u16,
    pub vlan_tci: u16,
    pub __bindgen_anon_4: rte_mbuf__bindgen_ty_4,
    pub vlan_tci_outer: u16,
    pub buf_len: u16,
    pub timestamp: u64,
    pub cacheline1: MARKER,
    pub __bindgen_anon_5: rte_mbuf__bindgen_ty_5,
    pub pool: *mut rte_mempool,
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_6: rte_mbuf__bindgen_ty_6,
    pub priv_size: u16,
    pub timesync: u16,
    pub seqn: u32,
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    pub dynfield1: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub buf_iova: rte_iova_t,
    pub buf_physaddr: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1>())).buf_iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(buf_iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1>())).buf_physaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(buf_physaddr)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub refcnt_atomic: rte_atomic16_t,
    pub refcnt: u16,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2>())).refcnt_atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(refcnt_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2>())).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub inner_esp_next_proto: u8,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()))
                .inner_esp_next_proto as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(inner_esp_next_proto)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u32,
        l3_type: u32,
        l4_type: u32,
        tun_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u32 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u32 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u32 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u32 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u32 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3>())).packet_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(packet_type)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4 {
    pub hash: rte_mbuf__bindgen_ty_4__bindgen_ty_1,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4__bindgen_ty_1 {
    pub rss: u32,
    pub fdir: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    pub txadapter: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .id as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . lo as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>())).hi
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>())).reserved1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>())).reserved2
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>())).txq
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(txq)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).rss as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).fdir as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(fdir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).sched as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).txadapter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(txadapter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).usr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(usr)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_5 {
    pub userdata: *mut ::std::os::raw::c_void,
    pub udata64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_5>())).userdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_5),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_5>())).udata64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_5),
            "::",
            stringify!(udata64)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_6 {
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_6__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u16>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_6__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_6__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_6__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_6__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_6>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_6>())).tx_offload as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_6),
            "::",
            stringify!(tx_offload)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rearm_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rearm_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_off as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).nb_segs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(nb_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).port as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).ol_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rx_descriptor_fields1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rx_descriptor_fields1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pkt_len as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci_outer as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci_outer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_len as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).timestamp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pool as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).next as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).priv_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).timesync as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timesync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).seqn as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(seqn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).shinfo as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(shinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).dynfield1 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(dynfield1)
        )
    );
}
impl Default for rte_mbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mbuf_ext_shared_info {
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt_atomic: rte_atomic16_t,
}
#[test]
fn bindgen_test_layout_rte_mbuf_ext_shared_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_ext_shared_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_ext_shared_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).free_cb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).fcb_opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(fcb_opaque)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).refcnt_atomic as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(refcnt_atomic)
        )
    );
}
impl Default for rte_mbuf_ext_shared_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pktmbuf_pool_private {
    pub mbuf_data_room_size: u16,
    pub mbuf_priv_size: u16,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_pool_private() {
    assert_eq!(
        ::std::mem::size_of::<rte_pktmbuf_pool_private>(),
        8usize,
        concat!("Size of: ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pktmbuf_pool_private>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_data_room_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_data_room_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_priv_size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rte_mbuf_check(
        m: *const rte_mbuf,
        is_header: ::std::os::raw::c_int,
        reason: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_pktmbuf_pool_create_by_ops(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ops_name: *const ::std::os::raw::c_char,
    ) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_pktmbuf_free_bulk(mbufs: *mut *mut rte_mbuf, count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rte_pktmbuf_clone(md: *mut rte_mbuf, mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    pub fn rte_pktmbuf_copy(
        m: *const rte_mbuf,
        mp: *mut rte_mempool,
        offset: u32,
        length: u32,
    ) -> *mut rte_mbuf;
}
extern "C" {
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ether_addr {
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_rte_ether_addr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ether_addr>(),
        6usize,
        concat!("Size of: ", stringify!(rte_ether_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ether_addr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ether_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_addr>())).addr_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ether_addr),
            "::",
            stringify!(addr_bytes)
        )
    );
}
extern "C" {
    pub fn rte_eth_random_addr(addr: *mut u8);
}
extern "C" {
    pub fn rte_ether_format_addr(
        buf: *mut ::std::os::raw::c_char,
        size: u16,
        eth_addr: *const rte_ether_addr,
    );
}
extern "C" {
    pub fn rte_ether_unformat_addr(
        str: *const ::std::os::raw::c_char,
        eth_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ether_hdr {
    pub d_addr: rte_ether_addr,
    pub s_addr: rte_ether_addr,
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_ether_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ether_hdr>(),
        14usize,
        concat!("Size of: ", stringify!(rte_ether_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ether_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ether_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_hdr>())).d_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ether_hdr),
            "::",
            stringify!(d_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_hdr>())).s_addr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ether_hdr),
            "::",
            stringify!(s_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_hdr>())).ether_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ether_hdr),
            "::",
            stringify!(ether_type)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_vlan_hdr {
    pub vlan_tci: u16,
    pub eth_proto: u16,
}
#[test]
fn bindgen_test_layout_rte_vlan_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_vlan_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(rte_vlan_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vlan_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_vlan_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_hdr>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_hdr),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_hdr>())).eth_proto as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_hdr),
            "::",
            stringify!(eth_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_reg_info {
    pub data: *mut ::std::os::raw::c_void,
    pub offset: u32,
    pub length: u32,
    pub width: u32,
    pub version: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_reg_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_reg_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_reg_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(version)
        )
    );
}
impl Default for rte_dev_reg_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_eeprom_info {
    pub data: *mut ::std::os::raw::c_void,
    pub offset: u32,
    pub length: u32,
    pub magic: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_eeprom_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_eeprom_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_eeprom_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).magic as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for rte_dev_eeprom_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_module_info {
    pub type_: u32,
    pub eeprom_len: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_module_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_module_info>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_dev_module_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_module_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_module_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_module_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_module_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_module_info>())).eeprom_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_module_info),
            "::",
            stringify!(eeprom_len)
        )
    );
}
extern "C" {
    pub static mut rte_eth_dev_logtype: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_iterator_init(
        iter: *mut rte_dev_iterator,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_iterator_next(iter: *mut rte_dev_iterator) -> u16;
}
extern "C" {
    pub fn rte_eth_iterator_cleanup(iter: *mut rte_dev_iterator);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_stats {
    pub ipackets: u64,
    pub opackets: u64,
    pub ibytes: u64,
    pub obytes: u64,
    pub imissed: u64,
    pub ierrors: u64,
    pub oerrors: u64,
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_stats>(),
        704usize,
        concat!("Size of: ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ipackets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).opackets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ibytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).obytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).imissed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(imissed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ierrors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ierrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).oerrors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(oerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).rx_nombuf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(rx_nombuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ipackets as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_opackets as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ibytes as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_obytes as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_errors as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_errors)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_link {
    pub link_speed: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_link>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_link))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_link>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_link))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_link>())).link_speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_link),
            "::",
            stringify!(link_speed)
        )
    );
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_thresh {
    pub pthresh: u8,
    pub hthresh: u8,
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_thresh>(),
        3usize,
        concat!("Size of: ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_thresh>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).pthresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(pthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).hthresh as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(hthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).wthresh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(wthresh)
        )
    );
}
pub mod rte_eth_rx_mq_mode {
    pub type Type = u32;
    pub const ETH_MQ_RX_NONE: Type = 0;
    pub const ETH_MQ_RX_RSS: Type = 1;
    pub const ETH_MQ_RX_DCB: Type = 2;
    pub const ETH_MQ_RX_DCB_RSS: Type = 3;
    pub const ETH_MQ_RX_VMDQ_ONLY: Type = 4;
    pub const ETH_MQ_RX_VMDQ_RSS: Type = 5;
    pub const ETH_MQ_RX_VMDQ_DCB: Type = 6;
    pub const ETH_MQ_RX_VMDQ_DCB_RSS: Type = 7;
}
pub mod rte_eth_tx_mq_mode {
    pub type Type = u32;
    pub const ETH_MQ_TX_NONE: Type = 0;
    pub const ETH_MQ_TX_DCB: Type = 1;
    pub const ETH_MQ_TX_VMDQ_DCB: Type = 2;
    pub const ETH_MQ_TX_VMDQ_ONLY: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rxmode {
    pub mq_mode: rte_eth_rx_mq_mode::Type,
    pub max_rx_pkt_len: u32,
    pub max_lro_pkt_size: u32,
    pub split_hdr_size: u16,
    pub offloads: u64,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxmode>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).max_rx_pkt_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_rx_pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).max_lro_pkt_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_lro_pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).split_hdr_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(split_hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).reserved_64s as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).reserved_ptrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_rxmode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_vlan_type {
    pub type Type = u32;
    pub const ETH_VLAN_TYPE_UNKNOWN: Type = 0;
    pub const ETH_VLAN_TYPE_INNER: Type = 1;
    pub const ETH_VLAN_TYPE_OUTER: Type = 2;
    pub const ETH_VLAN_TYPE_MAX: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[test]
fn bindgen_test_layout_rte_vlan_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_vlan_filter_conf>(),
        512usize,
        concat!("Size of: ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vlan_filter_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_filter_conf>())).ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_filter_conf),
            "::",
            stringify!(ids)
        )
    );
}
impl Default for rte_vlan_filter_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rss_conf {
    pub rss_key: *mut u8,
    pub rss_key_len: u8,
    pub rss_hf: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_hf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_hf)
        )
    );
}
impl Default for rte_eth_rss_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vlan_mirror {
    pub vlan_mask: u64,
    pub vlan_id: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vlan_mirror() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vlan_mirror>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vlan_mirror>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_id)
        )
    );
}
impl Default for rte_eth_vlan_mirror {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_mirror_conf {
    pub rule_type: u8,
    pub dst_pool: u8,
    pub pool_mask: u64,
    pub vlan: rte_eth_vlan_mirror,
}
#[test]
fn bindgen_test_layout_rte_eth_mirror_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mirror_conf>(),
        152usize,
        concat!("Size of: ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mirror_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).rule_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(rule_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).dst_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(dst_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).pool_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(pool_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).vlan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(vlan)
        )
    );
}
impl Default for rte_eth_mirror_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rss_reta_entry64() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_reta_entry64>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_reta_entry64>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).reta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(reta)
        )
    );
}
impl Default for rte_eth_rss_reta_entry64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_nb_tcs {
    pub type Type = u32;
    pub const ETH_4_TCS: Type = 4;
    pub const ETH_8_TCS: Type = 8;
}
pub mod rte_eth_nb_pools {
    pub type Type = u32;
    pub const ETH_8_POOLS: Type = 8;
    pub const ETH_16_POOLS: Type = 16;
    pub const ETH_32_POOLS: Type = 32;
    pub const ETH_64_POOLS: Type = 64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_rx_conf {
    pub nb_tcs: rte_eth_nb_tcs::Type,
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_rx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_rx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_dcb_rx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_vmdq_dcb_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tx_conf {
    pub nb_tcs: rte_eth_nb_tcs::Type,
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_dcb_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_tx_conf {
    pub nb_queue_pools: rte_eth_nb_pools::Type,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_tx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
}
impl Default for rte_eth_vmdq_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    pub enable_default_pool: u8,
    pub default_pool: u8,
    pub nb_pool_maps: u8,
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    pub vlan_id: u16,
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).vlan_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).pools as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).enable_default_pool as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).default_pool as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_pool_maps as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).pool_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(pool_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).dcb_tc as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_vmdq_dcb_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    pub enable_default_pool: u8,
    pub default_pool: u8,
    pub enable_loop_back: u8,
    pub nb_pool_maps: u8,
    pub rx_mode: u32,
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    pub vlan_id: u16,
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).vlan_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).pools as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_default_pool as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).default_pool as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_loop_back as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_loop_back)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_pool_maps as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).rx_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(rx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).pool_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(pool_map)
        )
    );
}
impl Default for rte_eth_vmdq_rx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_txmode {
    pub mq_mode: rte_eth_tx_mq_mode::Type,
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txmode>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).offloads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).pvid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(pvid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).reserved_64s as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).reserved_ptrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_txmode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rxconf {
    pub rx_thresh: rte_eth_thresh,
    pub rx_free_thresh: u16,
    pub rx_drop_en: u8,
    pub rx_deferred_start: u8,
    pub offloads: u64,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxconf>(),
        48usize,
        concat!("Size of: ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_free_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_drop_en as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_drop_en)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_deferred_start as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).offloads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).reserved_64s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).reserved_ptrs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_rxconf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_txconf {
    pub tx_thresh: rte_eth_thresh,
    pub tx_rs_thresh: u16,
    pub tx_free_thresh: u16,
    pub tx_deferred_start: u8,
    pub offloads: u64,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txconf>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_rs_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_rs_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_free_thresh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_free_thresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_txconf>())).tx_deferred_start as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).reserved_64s as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).reserved_ptrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_txconf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_hairpin_cap {
    pub max_nb_queues: u16,
    pub max_rx_2_tx: u16,
    pub max_tx_2_rx: u16,
    pub max_nb_desc: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_hairpin_cap() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hairpin_cap>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_hairpin_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hairpin_cap>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_hairpin_cap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_nb_queues as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_nb_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_rx_2_tx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_rx_2_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_tx_2_rx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_tx_2_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_nb_desc as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_nb_desc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_hairpin_peer {
    pub port: u16,
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_hairpin_peer() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hairpin_peer>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_hairpin_peer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hairpin_peer>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_hairpin_peer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_peer>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_peer),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_peer>())).queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_peer),
            "::",
            stringify!(queue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_hairpin_conf {
    pub peer_count: u16,
    pub peers: [rte_eth_hairpin_peer; 32usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hairpin_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hairpin_conf>(),
        130usize,
        concat!("Size of: ", stringify!(rte_eth_hairpin_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hairpin_conf>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_hairpin_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_conf>())).peer_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_conf),
            "::",
            stringify!(peer_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_conf>())).peers as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_conf),
            "::",
            stringify!(peers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_desc_lim {
    pub nb_max: u16,
    pub nb_min: u16,
    pub nb_align: u16,
    pub nb_seg_max: u16,
    pub nb_mtu_seg_max: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_desc_lim>(),
        10usize,
        concat!("Size of: ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_desc_lim>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_min as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_seg_max as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_seg_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_mtu_seg_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_mtu_seg_max)
        )
    );
}
pub mod rte_eth_fc_mode {
    pub type Type = u32;
    pub const RTE_FC_NONE: Type = 0;
    pub const RTE_FC_RX_PAUSE: Type = 1;
    pub const RTE_FC_TX_PAUSE: Type = 2;
    pub const RTE_FC_FULL: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fc_conf {
    pub high_water: u32,
    pub low_water: u32,
    pub pause_time: u16,
    pub send_xon: u16,
    pub mode: rte_eth_fc_mode::Type,
    pub mac_ctrl_frame_fwd: u8,
    pub autoneg: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fc_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).high_water as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(high_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).low_water as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(low_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).pause_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(pause_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).send_xon as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(send_xon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).mode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fc_conf>())).mac_ctrl_frame_fwd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mac_ctrl_frame_fwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).autoneg as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(autoneg)
        )
    );
}
impl Default for rte_eth_fc_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_pfc_conf {
    pub fc: rte_eth_fc_conf,
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_pfc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_pfc_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_pfc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).fc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(priority)
        )
    );
}
impl Default for rte_eth_pfc_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_tunnel_type {
    pub type Type = u32;
    pub const RTE_TUNNEL_TYPE_NONE: Type = 0;
    pub const RTE_TUNNEL_TYPE_VXLAN: Type = 1;
    pub const RTE_TUNNEL_TYPE_GENEVE: Type = 2;
    pub const RTE_TUNNEL_TYPE_TEREDO: Type = 3;
    pub const RTE_TUNNEL_TYPE_NVGRE: Type = 4;
    pub const RTE_TUNNEL_TYPE_IP_IN_GRE: Type = 5;
    pub const RTE_L2_TUNNEL_TYPE_E_TAG: Type = 6;
    pub const RTE_TUNNEL_TYPE_VXLAN_GPE: Type = 7;
    pub const RTE_TUNNEL_TYPE_MAX: Type = 8;
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_arp_ipv4 {
    pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout_rte_arp_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_arp_ipv4>(),
        20usize,
        concat!("Size of: ", stringify!(rte_arp_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_arp_ipv4>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_arp_ipv4))
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_arp_hdr {
    pub _bindgen_opaque_blob: [u16; 14usize],
}
#[test]
fn bindgen_test_layout_rte_arp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_arp_hdr>(),
        28usize,
        concat!("Size of: ", stringify!(rte_arp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_arp_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_arp_hdr))
    );
}
extern "C" {
    pub fn rte_net_make_rarp_packet(
        mpool: *mut rte_mempool,
        mac: *const rte_ether_addr,
    ) -> *mut rte_mbuf;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: rte_be16_t,
    pub icmp_ident: rte_be16_t,
    pub icmp_seq_nb: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_icmp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_icmp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_icmp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_icmp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_icmp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_cksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_cksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_ident as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_ident)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_seq_nb as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_seq_nb)
        )
    );
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ipv4_hdr {
    pub version_ihl: u8,
    pub type_of_service: u8,
    pub total_length: rte_be16_t,
    pub packet_id: rte_be16_t,
    pub fragment_offset: rte_be16_t,
    pub time_to_live: u8,
    pub next_proto_id: u8,
    pub hdr_checksum: rte_be16_t,
    pub src_addr: rte_be32_t,
    pub dst_addr: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_ipv4_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ipv4_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(rte_ipv4_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ipv4_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_ipv4_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).version_ihl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(version_ihl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).type_of_service as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(type_of_service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).total_length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).packet_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).fragment_offset as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(fragment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).time_to_live as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(time_to_live)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).next_proto_id as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(next_proto_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).hdr_checksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(hdr_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).src_addr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).dst_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(dst_addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ipv6_hdr {
    pub vtc_flow: rte_be32_t,
    pub payload_len: rte_be16_t,
    pub proto: u8,
    pub hop_limits: u8,
    pub src_addr: [u8; 16usize],
    pub dst_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_ipv6_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ipv6_hdr>(),
        40usize,
        concat!("Size of: ", stringify!(rte_ipv6_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ipv6_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_ipv6_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).vtc_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(vtc_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).payload_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(payload_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).proto as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).hop_limits as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(hop_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).src_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).dst_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(dst_addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_sctp_hdr {
    pub src_port: rte_be16_t,
    pub dst_port: rte_be16_t,
    pub tag: rte_be32_t,
    pub cksum: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_sctp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_sctp_hdr>(),
        12usize,
        concat!("Size of: ", stringify!(rte_sctp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_sctp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_sctp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_sctp_hdr),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_sctp_hdr),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).tag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_sctp_hdr),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).cksum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_sctp_hdr),
            "::",
            stringify!(cksum)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_tcp_hdr {
    pub src_port: rte_be16_t,
    pub dst_port: rte_be16_t,
    pub sent_seq: rte_be32_t,
    pub recv_ack: rte_be32_t,
    pub data_off: u8,
    pub tcp_flags: u8,
    pub rx_win: rte_be16_t,
    pub cksum: rte_be16_t,
    pub tcp_urp: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_tcp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_tcp_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(rte_tcp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tcp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_tcp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).sent_seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(sent_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).recv_ack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(recv_ack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).data_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).tcp_flags as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).rx_win as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(rx_win)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).cksum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(cksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).tcp_urp as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(tcp_urp)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_udp_hdr {
    pub src_port: rte_be16_t,
    pub dst_port: rte_be16_t,
    pub dgram_len: rte_be16_t,
    pub dgram_cksum: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_udp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_udp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_udp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_udp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_udp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_udp_hdr),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_udp_hdr),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).dgram_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_udp_hdr),
            "::",
            stringify!(dgram_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).dgram_cksum as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_udp_hdr),
            "::",
            stringify!(dgram_cksum)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_esp_hdr {
    pub spi: rte_be32_t,
    pub seq: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_esp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_esp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_esp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_esp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_esp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_hdr>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_esp_hdr),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_hdr>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_esp_hdr),
            "::",
            stringify!(seq)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_esp_tail {
    pub pad_len: u8,
    pub next_proto: u8,
}
#[test]
fn bindgen_test_layout_rte_esp_tail() {
    assert_eq!(
        ::std::mem::size_of::<rte_esp_tail>(),
        2usize,
        concat!("Size of: ", stringify!(rte_esp_tail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_esp_tail>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_esp_tail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_tail>())).pad_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_esp_tail),
            "::",
            stringify!(pad_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_tail>())).next_proto as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_esp_tail),
            "::",
            stringify!(next_proto)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_higig2_frc {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_higig2_frc() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_frc>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_frc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_frc>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_frc))
    );
}
impl rte_higig2_frc {
    #[inline]
    pub fn ksop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ksop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mcst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn src_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn src_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lbid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lbid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ppd_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ppd_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn resv1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ksop: u32,
        tc: u32,
        mcst: u32,
        resv: u32,
        dst_modid: u32,
        dst_pid: u32,
        src_modid: u32,
        src_pid: u32,
        lbid: u32,
        ppd_type: u32,
        resv1: u32,
        dp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ksop: u32 = unsafe { ::std::mem::transmute(ksop) };
            ksop as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let tc: u32 = unsafe { ::std::mem::transmute(tc) };
            tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mcst: u32 = unsafe { ::std::mem::transmute(mcst) };
            mcst as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let resv: u32 = unsafe { ::std::mem::transmute(resv) };
            resv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let dst_modid: u32 = unsafe { ::std::mem::transmute(dst_modid) };
            dst_modid as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let dst_pid: u32 = unsafe { ::std::mem::transmute(dst_pid) };
            dst_pid as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let src_modid: u32 = unsafe { ::std::mem::transmute(src_modid) };
            src_modid as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let src_pid: u32 = unsafe { ::std::mem::transmute(src_pid) };
            src_pid as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let lbid: u32 = unsafe { ::std::mem::transmute(lbid) };
            lbid as u64
        });
        __bindgen_bitfield_unit.set(56usize, 3u8, {
            let ppd_type: u32 = unsafe { ::std::mem::transmute(ppd_type) };
            ppd_type as u64
        });
        __bindgen_bitfield_unit.set(59usize, 3u8, {
            let resv1: u32 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 2u8, {
            let dp: u32 = unsafe { ::std::mem::transmute(dp) };
            dp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_higig2_ppt_type0 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_higig2_ppt_type0() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_ppt_type0>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_ppt_type0))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_ppt_type0>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_ppt_type0))
    );
}
impl rte_higig2_ppt_type0 {
    #[inline]
    pub fn mirror(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_done(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ingress_tagged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress_tagged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_tgid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dst_tgid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dst_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn label_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_label_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vid_high(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vid_low(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn opc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn srce_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_srce_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdr_ext_length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hdr_ext_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mirror: u32,
        mirror_done: u32,
        mirror_only: u32,
        ingress_tagged: u32,
        dst_tgid: u32,
        dst_t: u32,
        vc_label2: u32,
        label_present: u32,
        l3: u32,
        res: u32,
        vc_label1: u32,
        vc_label0: u32,
        vid_high: u32,
        vid_low: u32,
        opc: u32,
        res1: u32,
        srce_t: u32,
        pf: u32,
        res2: u32,
        hdr_ext_length: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mirror: u32 = unsafe { ::std::mem::transmute(mirror) };
            mirror as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mirror_done: u32 = unsafe { ::std::mem::transmute(mirror_done) };
            mirror_done as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mirror_only: u32 = unsafe { ::std::mem::transmute(mirror_only) };
            mirror_only as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ingress_tagged: u32 = unsafe { ::std::mem::transmute(ingress_tagged) };
            ingress_tagged as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let dst_tgid: u32 = unsafe { ::std::mem::transmute(dst_tgid) };
            dst_tgid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dst_t: u32 = unsafe { ::std::mem::transmute(dst_t) };
            dst_t as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let vc_label2: u32 = unsafe { ::std::mem::transmute(vc_label2) };
            vc_label2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let label_present: u32 = unsafe { ::std::mem::transmute(label_present) };
            label_present as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let l3: u32 = unsafe { ::std::mem::transmute(l3) };
            l3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let vc_label1: u32 = unsafe { ::std::mem::transmute(vc_label1) };
            vc_label1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let vc_label0: u32 = unsafe { ::std::mem::transmute(vc_label0) };
            vc_label0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let vid_high: u32 = unsafe { ::std::mem::transmute(vid_high) };
            vid_high as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let vid_low: u32 = unsafe { ::std::mem::transmute(vid_low) };
            vid_low as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let opc: u32 = unsafe { ::std::mem::transmute(opc) };
            opc as u64
        });
        __bindgen_bitfield_unit.set(51usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let srce_t: u32 = unsafe { ::std::mem::transmute(srce_t) };
            srce_t as u64
        });
        __bindgen_bitfield_unit.set(54usize, 2u8, {
            let pf: u32 = unsafe { ::std::mem::transmute(pf) };
            pf as u64
        });
        __bindgen_bitfield_unit.set(56usize, 5u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let hdr_ext_length: u32 = unsafe { ::std::mem::transmute(hdr_ext_length) };
            hdr_ext_length as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_higig2_ppt_type1 {
    pub classification: u16,
    pub resv: u16,
    pub vid: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_higig2_ppt_type1() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_ppt_type1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_ppt_type1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_ppt_type1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_higig2_ppt_type1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_higig2_ppt_type1>())).classification as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_ppt_type1),
            "::",
            stringify!(classification)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_ppt_type1>())).resv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_ppt_type1),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_ppt_type1>())).vid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_ppt_type1),
            "::",
            stringify!(vid)
        )
    );
}
impl rte_higig2_ppt_type1 {
    #[inline]
    pub fn opcode(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn resv1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn src_t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_src_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfm(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pfm(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn resv2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_resv2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdr_ext_len(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_hdr_ext_len(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opcode: u16,
        resv1: u16,
        src_t: u16,
        pfm: u16,
        resv2: u16,
        hdr_ext_len: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let opcode: u16 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let resv1: u16 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let src_t: u16 = unsafe { ::std::mem::transmute(src_t) };
            src_t as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let pfm: u16 = unsafe { ::std::mem::transmute(pfm) };
            pfm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let resv2: u16 = unsafe { ::std::mem::transmute(resv2) };
            resv2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdr_ext_len: u16 = unsafe { ::std::mem::transmute(hdr_ext_len) };
            hdr_ext_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_higig2_hdr {
    pub fcr: rte_higig2_frc,
    pub __bindgen_anon_1: rte_higig2_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_higig2_hdr__bindgen_ty_1 {
    pub ppt0: rte_higig2_ppt_type0,
    pub ppt1: rte_higig2_ppt_type1,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_rte_higig2_hdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_hdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_hdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_hdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_hdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_higig2_hdr__bindgen_ty_1>())).ppt0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_hdr__bindgen_ty_1),
            "::",
            stringify!(ppt0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_higig2_hdr__bindgen_ty_1>())).ppt1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_hdr__bindgen_ty_1),
            "::",
            stringify!(ppt1)
        )
    );
}
impl Default for rte_higig2_hdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_higig2_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(rte_higig2_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_hdr>())).fcr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_hdr),
            "::",
            stringify!(fcr)
        )
    );
}
impl Default for rte_higig2_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_dynfield {
    pub name: [::std::os::raw::c_char; 64usize],
    pub size: size_t,
    pub align: size_t,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mbuf_dynfield() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_dynfield>(),
        88usize,
        concat!("Size of: ", stringify!(rte_mbuf_dynfield))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_dynfield>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf_dynfield))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).align as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_mbuf_dynfield {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_dynflag {
    pub name: [::std::os::raw::c_char; 64usize],
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mbuf_dynflag() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_dynflag>(),
        68usize,
        concat!("Size of: ", stringify!(rte_mbuf_dynflag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_dynflag>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf_dynflag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynflag>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynflag),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynflag>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynflag),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_mbuf_dynflag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_mbuf_dynfield_register(params: *const rte_mbuf_dynfield) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mbuf_dynfield_register_offset(
        params: *const rte_mbuf_dynfield,
        offset: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mbuf_dynfield_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynfield,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mbuf_dynflag_register(params: *const rte_mbuf_dynflag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mbuf_dynflag_register_bitnum(
        params: *const rte_mbuf_dynflag,
        bitnum: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mbuf_dynflag_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynflag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mbuf_dyn_dump(out: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_attr {
    pub group: u32,
    pub priority: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_attr() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_attr>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_attr>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_attr),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_attr>())).priority as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_attr),
            "::",
            stringify!(priority)
        )
    );
}
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod rte_flow_item_type {
    pub type Type = u32;
    pub const RTE_FLOW_ITEM_TYPE_END: Type = 0;
    pub const RTE_FLOW_ITEM_TYPE_VOID: Type = 1;
    pub const RTE_FLOW_ITEM_TYPE_INVERT: Type = 2;
    pub const RTE_FLOW_ITEM_TYPE_ANY: Type = 3;
    pub const RTE_FLOW_ITEM_TYPE_PF: Type = 4;
    pub const RTE_FLOW_ITEM_TYPE_VF: Type = 5;
    pub const RTE_FLOW_ITEM_TYPE_PHY_PORT: Type = 6;
    pub const RTE_FLOW_ITEM_TYPE_PORT_ID: Type = 7;
    pub const RTE_FLOW_ITEM_TYPE_RAW: Type = 8;
    pub const RTE_FLOW_ITEM_TYPE_ETH: Type = 9;
    pub const RTE_FLOW_ITEM_TYPE_VLAN: Type = 10;
    pub const RTE_FLOW_ITEM_TYPE_IPV4: Type = 11;
    pub const RTE_FLOW_ITEM_TYPE_IPV6: Type = 12;
    pub const RTE_FLOW_ITEM_TYPE_ICMP: Type = 13;
    pub const RTE_FLOW_ITEM_TYPE_UDP: Type = 14;
    pub const RTE_FLOW_ITEM_TYPE_TCP: Type = 15;
    pub const RTE_FLOW_ITEM_TYPE_SCTP: Type = 16;
    pub const RTE_FLOW_ITEM_TYPE_VXLAN: Type = 17;
    pub const RTE_FLOW_ITEM_TYPE_E_TAG: Type = 18;
    pub const RTE_FLOW_ITEM_TYPE_NVGRE: Type = 19;
    pub const RTE_FLOW_ITEM_TYPE_MPLS: Type = 20;
    pub const RTE_FLOW_ITEM_TYPE_GRE: Type = 21;
    pub const RTE_FLOW_ITEM_TYPE_FUZZY: Type = 22;
    pub const RTE_FLOW_ITEM_TYPE_GTP: Type = 23;
    pub const RTE_FLOW_ITEM_TYPE_GTPC: Type = 24;
    pub const RTE_FLOW_ITEM_TYPE_GTPU: Type = 25;
    pub const RTE_FLOW_ITEM_TYPE_ESP: Type = 26;
    pub const RTE_FLOW_ITEM_TYPE_GENEVE: Type = 27;
    pub const RTE_FLOW_ITEM_TYPE_VXLAN_GPE: Type = 28;
    pub const RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4: Type = 29;
    pub const RTE_FLOW_ITEM_TYPE_IPV6_EXT: Type = 30;
    pub const RTE_FLOW_ITEM_TYPE_ICMP6: Type = 31;
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS: Type = 32;
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA: Type = 33;
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT: Type = 34;
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH: Type = 35;
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH: Type = 36;
    pub const RTE_FLOW_ITEM_TYPE_MARK: Type = 37;
    pub const RTE_FLOW_ITEM_TYPE_META: Type = 38;
    pub const RTE_FLOW_ITEM_TYPE_GRE_KEY: Type = 39;
    pub const RTE_FLOW_ITEM_TYPE_GTP_PSC: Type = 40;
    pub const RTE_FLOW_ITEM_TYPE_PPPOES: Type = 41;
    pub const RTE_FLOW_ITEM_TYPE_PPPOED: Type = 42;
    pub const RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID: Type = 43;
    pub const RTE_FLOW_ITEM_TYPE_NSH: Type = 44;
    pub const RTE_FLOW_ITEM_TYPE_IGMP: Type = 45;
    pub const RTE_FLOW_ITEM_TYPE_AH: Type = 46;
    pub const RTE_FLOW_ITEM_TYPE_HIGIG2: Type = 47;
    pub const RTE_FLOW_ITEM_TYPE_TAG: Type = 48;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_higig2_hdr {
    pub hdr: rte_higig2_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_higig2_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_higig2_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_item_higig2_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_higig2_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_higig2_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_higig2_hdr>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_higig2_hdr),
            "::",
            stringify!(hdr)
        )
    );
}
impl Default for rte_flow_item_higig2_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static rte_flow_item_higig2_hdr_mask: rte_flow_item_higig2_hdr;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_any {
    pub num: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_any() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_any>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_any))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_any>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_any))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_any>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_any),
            "::",
            stringify!(num)
        )
    );
}
extern "C" {
    pub static rte_flow_item_any_mask: rte_flow_item_any;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vf {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vf() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_vf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vf>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vf),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_vf_mask: rte_flow_item_vf;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_phy_port {
    pub index: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_phy_port() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_phy_port>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_phy_port))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_phy_port>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_phy_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_phy_port>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_phy_port),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub static rte_flow_item_phy_port_mask: rte_flow_item_phy_port;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_port_id {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_port_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_port_id>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_port_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_port_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_port_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_port_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_port_id),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_port_id_mask: rte_flow_item_port_id;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_item_raw {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub offset: i32,
    pub limit: u16,
    pub length: u16,
    pub pattern: *const u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_raw() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_raw>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_item_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_raw>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_item_raw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).length as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).pattern as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(pattern)
        )
    );
}
impl Default for rte_flow_item_raw {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_flow_item_raw {
    #[inline]
    pub fn relative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        relative: u32,
        search: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let relative: u32 = unsafe { ::std::mem::transmute(relative) };
            relative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let search: u32 = unsafe { ::std::mem::transmute(search) };
            search as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_raw_mask: rte_flow_item_raw;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_eth {
    pub dst: rte_ether_addr,
    pub src: rte_ether_addr,
    pub type_: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_eth() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_eth>(),
        14usize,
        concat!("Size of: ", stringify!(rte_flow_item_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_eth>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_eth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_eth>())).dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_eth),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_eth>())).src as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_eth),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_eth>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_eth),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    pub static rte_flow_item_eth_mask: rte_flow_item_eth;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vlan {
    pub tci: rte_be16_t,
    pub inner_type: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vlan() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vlan>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_vlan))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vlan>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vlan>())).tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vlan),
            "::",
            stringify!(tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vlan>())).inner_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vlan),
            "::",
            stringify!(inner_type)
        )
    );
}
extern "C" {
    pub static rte_flow_item_vlan_mask: rte_flow_item_vlan;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ipv4 {
    pub hdr: rte_ipv4_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ipv4>(),
        20usize,
        concat!("Size of: ", stringify!(rte_flow_item_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ipv4>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ipv4>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ipv4),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_ipv4_mask: rte_flow_item_ipv4;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ipv6 {
    pub hdr: rte_ipv6_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv6() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ipv6>(),
        40usize,
        concat!("Size of: ", stringify!(rte_flow_item_ipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ipv6>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ipv6>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ipv6),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_ipv6_mask: rte_flow_item_ipv6;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp {
    pub hdr: rte_icmp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp_mask: rte_flow_item_icmp;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_udp {
    pub hdr: rte_udp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_udp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_udp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_udp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_udp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_udp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_udp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_udp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_udp_mask: rte_flow_item_udp;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_tcp {
    pub hdr: rte_tcp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_tcp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_tcp>(),
        20usize,
        concat!("Size of: ", stringify!(rte_flow_item_tcp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_tcp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_tcp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_tcp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_tcp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_tcp_mask: rte_flow_item_tcp;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_sctp {
    pub hdr: rte_sctp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_sctp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_sctp>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_item_sctp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_sctp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_sctp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_sctp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_sctp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_sctp_mask: rte_flow_item_sctp;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vxlan {
    pub flags: u8,
    pub rsvd0: [u8; 3usize],
    pub vni: [u8; 3usize],
    pub rsvd1: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vxlan() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vxlan>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_vxlan))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vxlan>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vxlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).rsvd0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(rsvd0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(vni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).rsvd1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(rsvd1)
        )
    );
}
extern "C" {
    pub static rte_flow_item_vxlan_mask: rte_flow_item_vxlan;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_e_tag {
    pub epcp_edei_in_ecid_b: rte_be16_t,
    pub rsvd_grp_ecid_b: rte_be16_t,
    pub in_ecid_e: u8,
    pub ecid_e: u8,
    pub inner_type: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_e_tag() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_e_tag>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_e_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_e_tag>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_e_tag))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_e_tag>())).epcp_edei_in_ecid_b as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(epcp_edei_in_ecid_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_e_tag>())).rsvd_grp_ecid_b as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(rsvd_grp_ecid_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).in_ecid_e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(in_ecid_e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).ecid_e as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(ecid_e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).inner_type as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(inner_type)
        )
    );
}
extern "C" {
    pub static rte_flow_item_e_tag_mask: rte_flow_item_e_tag;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_nvgre {
    pub c_k_s_rsvd0_ver: rte_be16_t,
    pub protocol: rte_be16_t,
    pub tni: [u8; 3usize],
    pub flow_id: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_nvgre() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_nvgre>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_nvgre))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_nvgre>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_nvgre))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_nvgre>())).c_k_s_rsvd0_ver as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(c_k_s_rsvd0_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_nvgre>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_nvgre>())).tni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(tni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_nvgre>())).flow_id as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(flow_id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_nvgre_mask: rte_flow_item_nvgre;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_mpls {
    pub label_tc_s: [u8; 3usize],
    pub ttl: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_mpls() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_mpls>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_mpls>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_mpls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_mpls>())).label_tc_s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_mpls),
            "::",
            stringify!(label_tc_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_mpls>())).ttl as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_mpls),
            "::",
            stringify!(ttl)
        )
    );
}
extern "C" {
    pub static rte_flow_item_mpls_mask: rte_flow_item_mpls;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_gre {
    pub c_rsvd0_ver: rte_be16_t,
    pub protocol: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_gre() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_gre>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_gre))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_gre>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_gre))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gre>())).c_rsvd0_ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gre),
            "::",
            stringify!(c_rsvd0_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gre>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gre),
            "::",
            stringify!(protocol)
        )
    );
}
extern "C" {
    pub static rte_flow_item_gre_mask: rte_flow_item_gre;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_fuzzy {
    pub thresh: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_fuzzy() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_fuzzy>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_fuzzy))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_fuzzy>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_fuzzy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_fuzzy>())).thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_fuzzy),
            "::",
            stringify!(thresh)
        )
    );
}
extern "C" {
    pub static rte_flow_item_fuzzy_mask: rte_flow_item_fuzzy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_gtp {
    pub v_pt_rsv_flags: u8,
    pub msg_type: u8,
    pub msg_len: rte_be16_t,
    pub teid: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_gtp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_gtp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_gtp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_gtp>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_gtp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_gtp>())).v_pt_rsv_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(v_pt_rsv_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp>())).msg_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(msg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp>())).msg_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(msg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp>())).teid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(teid)
        )
    );
}
extern "C" {
    pub static rte_flow_item_gtp_mask: rte_flow_item_gtp;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_esp {
    pub hdr: rte_esp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_esp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_esp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_esp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_esp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_esp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_esp_mask: rte_flow_item_esp;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_geneve {
    pub ver_opt_len_o_c_rsvd0: rte_be16_t,
    pub protocol: rte_be16_t,
    pub vni: [u8; 3usize],
    pub rsvd1: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_geneve() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_geneve>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_geneve))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_geneve>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_geneve))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_geneve>())).ver_opt_len_o_c_rsvd0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(ver_opt_len_o_c_rsvd0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_geneve>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_geneve>())).vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(vni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_geneve>())).rsvd1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(rsvd1)
        )
    );
}
extern "C" {
    pub static rte_flow_item_geneve_mask: rte_flow_item_geneve;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vxlan_gpe {
    pub flags: u8,
    pub rsvd0: [u8; 2usize],
    pub protocol: u8,
    pub vni: [u8; 3usize],
    pub rsvd1: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vxlan_gpe() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vxlan_gpe>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_vxlan_gpe))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vxlan_gpe>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vxlan_gpe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).rsvd0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(rsvd0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).protocol as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(vni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).rsvd1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(rsvd1)
        )
    );
}
extern "C" {
    pub static rte_flow_item_vxlan_gpe_mask: rte_flow_item_vxlan_gpe;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_arp_eth_ipv4 {
    pub hrd: rte_be16_t,
    pub pro: rte_be16_t,
    pub hln: u8,
    pub pln: u8,
    pub op: rte_be16_t,
    pub sha: rte_ether_addr,
    pub spa: rte_be32_t,
    pub tha: rte_ether_addr,
    pub tpa: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_arp_eth_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_arp_eth_ipv4>(),
        32usize,
        concat!("Size of: ", stringify!(rte_flow_item_arp_eth_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_arp_eth_ipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_arp_eth_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).hrd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(hrd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).pro as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(pro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).hln as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(hln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).pln as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(pln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).op as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).sha as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(sha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).spa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(spa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).tha as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(tha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).tpa as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(tpa)
        )
    );
}
extern "C" {
    pub static rte_flow_item_arp_eth_ipv4_mask: rte_flow_item_arp_eth_ipv4;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ipv6_ext {
    pub next_hdr: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv6_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ipv6_ext>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_item_ipv6_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ipv6_ext>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ipv6_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ipv6_ext>())).next_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ipv6_ext),
            "::",
            stringify!(next_hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_ipv6_ext_mask: rte_flow_item_ipv6_ext;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6 {
    pub type_: u8,
    pub code: u8,
    pub checksum: u16,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6>())).checksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6),
            "::",
            stringify!(checksum)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_mask: rte_flow_item_icmp6;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_ns {
    pub type_: u8,
    pub code: u8,
    pub checksum: rte_be16_t,
    pub reserved: rte_be32_t,
    pub target_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_ns() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_ns>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_ns))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_ns>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_ns))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).checksum as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).target_addr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(target_addr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_ns_mask: rte_flow_item_icmp6_nd_ns;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_na {
    pub type_: u8,
    pub code: u8,
    pub checksum: rte_be16_t,
    pub rso_reserved: rte_be32_t,
    pub target_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_na() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_na>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_na))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_na>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_na))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).checksum as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).rso_reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(rso_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).target_addr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(target_addr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_na_mask: rte_flow_item_icmp6_nd_na;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_opt {
    pub type_: u8,
    pub length: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_opt() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_opt>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_opt>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_opt))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt>())).length as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_mask: rte_flow_item_icmp6_nd_opt;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_opt_sla_eth {
    pub type_: u8,
    pub length: u8,
    pub sla: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_opt_sla_eth() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_opt_sla_eth>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_opt_sla_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_opt_sla_eth>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_flow_item_icmp6_nd_opt_sla_eth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_sla_eth>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_sla_eth),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_sla_eth>())).length as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_sla_eth),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_sla_eth>())).sla as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_sla_eth),
            "::",
            stringify!(sla)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_sla_eth_mask: rte_flow_item_icmp6_nd_opt_sla_eth;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_opt_tla_eth {
    pub type_: u8,
    pub length: u8,
    pub tla: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_opt_tla_eth() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_opt_tla_eth>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_opt_tla_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_opt_tla_eth>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_flow_item_icmp6_nd_opt_tla_eth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_tla_eth>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_tla_eth),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_tla_eth>())).length as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_tla_eth),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_tla_eth>())).tla as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_tla_eth),
            "::",
            stringify!(tla)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_tla_eth_mask: rte_flow_item_icmp6_nd_opt_tla_eth;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_meta {
    pub data: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_meta() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_meta>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_meta>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_meta>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_meta),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub static rte_flow_item_meta_mask: rte_flow_item_meta;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_gtp_psc {
    pub pdu_type: u8,
    pub qfi: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_gtp_psc() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_gtp_psc>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_item_gtp_psc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_gtp_psc>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_gtp_psc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp_psc>())).pdu_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp_psc),
            "::",
            stringify!(pdu_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp_psc>())).qfi as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp_psc),
            "::",
            stringify!(qfi)
        )
    );
}
extern "C" {
    pub static rte_flow_item_gtp_psc_mask: rte_flow_item_gtp_psc;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_pppoe {
    pub version_type: u8,
    pub code: u8,
    pub session_id: rte_be16_t,
    pub length: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_pppoe() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_pppoe>(),
        6usize,
        concat!("Size of: ", stringify!(rte_flow_item_pppoe))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_pppoe>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_pppoe))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_pppoe>())).version_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(version_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe>())).session_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_pppoe_proto_id {
    pub proto_id: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_pppoe_proto_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_pppoe_proto_id>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_item_pppoe_proto_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_pppoe_proto_id>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_pppoe_proto_id))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_item_pppoe_proto_id>())).proto_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe_proto_id),
            "::",
            stringify!(proto_id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_pppoe_proto_id_mask: rte_flow_item_pppoe_proto_id;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_tag {
    pub data: u32,
    pub index: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_tag() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_tag>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_tag>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_tag),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_tag>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_tag),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub static rte_flow_item_tag_mask: rte_flow_item_tag;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_mark {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_mark() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_mark>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_mark))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_mark>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_mark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_mark>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_mark),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_mark_mask: rte_flow_item_mark;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_nsh {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_item_nsh() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_nsh>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_nsh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_nsh>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_nsh))
    );
}
impl rte_flow_item_nsh {
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn oam_pkt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oam_pkt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ttl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mdtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mdtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn next_proto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_proto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn spi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_spi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn sindex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sindex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: u32,
        oam_pkt: u32,
        reserved: u32,
        ttl: u32,
        length: u32,
        reserved1: u32,
        mdtype: u32,
        next_proto: u32,
        spi: u32,
        sindex: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let oam_pkt: u32 = unsafe { ::std::mem::transmute(oam_pkt) };
            oam_pkt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let ttl: u32 = unsafe { ::std::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let mdtype: u32 = unsafe { ::std::mem::transmute(mdtype) };
            mdtype as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let next_proto: u32 = unsafe { ::std::mem::transmute(next_proto) };
            next_proto as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let spi: u32 = unsafe { ::std::mem::transmute(spi) };
            spi as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let sindex: u32 = unsafe { ::std::mem::transmute(sindex) };
            sindex as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_nsh_mask: rte_flow_item_nsh;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_igmp {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub group_addr: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_igmp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_igmp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_igmp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_igmp>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_igmp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_igmp>())).group_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_igmp),
            "::",
            stringify!(group_addr)
        )
    );
}
impl rte_flow_item_igmp {
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_resp_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_resp_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn checksum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_checksum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u32,
        max_resp_time: u32,
        checksum: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let max_resp_time: u32 = unsafe { ::std::mem::transmute(max_resp_time) };
            max_resp_time as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let checksum: u32 = unsafe { ::std::mem::transmute(checksum) };
            checksum as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_igmp_mask: rte_flow_item_igmp;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ah {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub spi: u32,
    pub seq_num: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ah() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ah>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_item_ah))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ah>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ah))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ah>())).spi as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ah),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ah>())).seq_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ah),
            "::",
            stringify!(seq_num)
        )
    );
}
impl rte_flow_item_ah {
    #[inline]
    pub fn next_hdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_hdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn payload_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_payload_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        next_hdr: u32,
        payload_len: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let next_hdr: u32 = unsafe { ::std::mem::transmute(next_hdr) };
            next_hdr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let payload_len: u32 = unsafe { ::std::mem::transmute(payload_len) };
            payload_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_ah_mask: rte_flow_item_ah;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_item {
    pub type_: rte_flow_item_type::Type,
    pub spec: *const ::std::os::raw::c_void,
    pub last: *const ::std::os::raw::c_void,
    pub mask: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_item() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item>(),
        32usize,
        concat!("Size of: ", stringify!(rte_flow_item))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_item))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).spec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item),
            "::",
            stringify!(spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).last as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for rte_flow_item {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_flow_action_type {
    pub type Type = u32;
    pub const RTE_FLOW_ACTION_TYPE_END: Type = 0;
    pub const RTE_FLOW_ACTION_TYPE_VOID: Type = 1;
    pub const RTE_FLOW_ACTION_TYPE_PASSTHRU: Type = 2;
    pub const RTE_FLOW_ACTION_TYPE_JUMP: Type = 3;
    pub const RTE_FLOW_ACTION_TYPE_MARK: Type = 4;
    pub const RTE_FLOW_ACTION_TYPE_FLAG: Type = 5;
    pub const RTE_FLOW_ACTION_TYPE_QUEUE: Type = 6;
    pub const RTE_FLOW_ACTION_TYPE_DROP: Type = 7;
    pub const RTE_FLOW_ACTION_TYPE_COUNT: Type = 8;
    pub const RTE_FLOW_ACTION_TYPE_RSS: Type = 9;
    pub const RTE_FLOW_ACTION_TYPE_PF: Type = 10;
    pub const RTE_FLOW_ACTION_TYPE_VF: Type = 11;
    pub const RTE_FLOW_ACTION_TYPE_PHY_PORT: Type = 12;
    pub const RTE_FLOW_ACTION_TYPE_PORT_ID: Type = 13;
    pub const RTE_FLOW_ACTION_TYPE_METER: Type = 14;
    pub const RTE_FLOW_ACTION_TYPE_SECURITY: Type = 15;
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL: Type = 16;
    pub const RTE_FLOW_ACTION_TYPE_OF_DEC_MPLS_TTL: Type = 17;
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL: Type = 18;
    pub const RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL: Type = 19;
    pub const RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_OUT: Type = 20;
    pub const RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_IN: Type = 21;
    pub const RTE_FLOW_ACTION_TYPE_OF_POP_VLAN: Type = 22;
    pub const RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN: Type = 23;
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID: Type = 24;
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP: Type = 25;
    pub const RTE_FLOW_ACTION_TYPE_OF_POP_MPLS: Type = 26;
    pub const RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS: Type = 27;
    pub const RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP: Type = 28;
    pub const RTE_FLOW_ACTION_TYPE_VXLAN_DECAP: Type = 29;
    pub const RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP: Type = 30;
    pub const RTE_FLOW_ACTION_TYPE_NVGRE_DECAP: Type = 31;
    pub const RTE_FLOW_ACTION_TYPE_RAW_ENCAP: Type = 32;
    pub const RTE_FLOW_ACTION_TYPE_RAW_DECAP: Type = 33;
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC: Type = 34;
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV4_DST: Type = 35;
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC: Type = 36;
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV6_DST: Type = 37;
    pub const RTE_FLOW_ACTION_TYPE_SET_TP_SRC: Type = 38;
    pub const RTE_FLOW_ACTION_TYPE_SET_TP_DST: Type = 39;
    pub const RTE_FLOW_ACTION_TYPE_MAC_SWAP: Type = 40;
    pub const RTE_FLOW_ACTION_TYPE_DEC_TTL: Type = 41;
    pub const RTE_FLOW_ACTION_TYPE_SET_TTL: Type = 42;
    pub const RTE_FLOW_ACTION_TYPE_SET_MAC_SRC: Type = 43;
    pub const RTE_FLOW_ACTION_TYPE_SET_MAC_DST: Type = 44;
    pub const RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ: Type = 45;
    pub const RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ: Type = 46;
    pub const RTE_FLOW_ACTION_TYPE_INC_TCP_ACK: Type = 47;
    pub const RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK: Type = 48;
    pub const RTE_FLOW_ACTION_TYPE_SET_TAG: Type = 49;
    pub const RTE_FLOW_ACTION_TYPE_SET_META: Type = 50;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_mark {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_mark() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_mark>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_mark))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_mark>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_mark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_mark>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_mark),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_jump {
    pub group: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_jump() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_jump>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_jump))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_jump>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_jump))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_jump>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_jump),
            "::",
            stringify!(group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_queue {
    pub index: u16,
}
#[test]
fn bindgen_test_layout_rte_flow_action_queue() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_queue>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_queue>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_queue>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_queue),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_count {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_count() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_count>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_count))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_count>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_count>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_count),
            "::",
            stringify!(id)
        )
    );
}
impl rte_flow_action_count {
    #[inline]
    pub fn shared(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(shared: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_query_count {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub hits: u64,
    pub bytes: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_query_count() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_query_count>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_query_count))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_query_count>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_query_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_query_count>())).hits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_query_count),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_query_count>())).bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_query_count),
            "::",
            stringify!(bytes)
        )
    );
}
impl rte_flow_query_count {
    #[inline]
    pub fn reset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hits_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hits_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bytes_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset: u32,
        hits_set: u32,
        bytes_set: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reset: u32 = unsafe { ::std::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hits_set: u32 = unsafe { ::std::mem::transmute(hits_set) };
            hits_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bytes_set: u32 = unsafe { ::std::mem::transmute(bytes_set) };
            bytes_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod rte_eth_hash_function {
    pub type Type = u32;
    pub const RTE_ETH_HASH_FUNCTION_DEFAULT: Type = 0;
    pub const RTE_ETH_HASH_FUNCTION_TOEPLITZ: Type = 1;
    pub const RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: Type = 2;
    pub const RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: Type = 3;
    pub const RTE_ETH_HASH_FUNCTION_MAX: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_rss {
    pub func: rte_eth_hash_function::Type,
    pub level: u32,
    pub types: u64,
    pub key_len: u32,
    pub queue_num: u32,
    pub key: *const u8,
    pub queue: *const u16,
}
#[test]
fn bindgen_test_layout_rte_flow_action_rss() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_rss>(),
        40usize,
        concat!("Size of: ", stringify!(rte_flow_action_rss))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_rss>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_rss))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).types as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).key_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).queue_num as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(queue)
        )
    );
}
impl Default for rte_flow_action_rss {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_vf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_vf() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_vf>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_vf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_vf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_vf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_vf>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_vf),
            "::",
            stringify!(id)
        )
    );
}
impl rte_flow_action_vf {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        original: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_phy_port {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub index: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_phy_port() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_phy_port>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_phy_port))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_phy_port>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_phy_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_phy_port>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_phy_port),
            "::",
            stringify!(index)
        )
    );
}
impl rte_flow_action_phy_port {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        original: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_port_id {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_port_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_port_id>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_port_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_port_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_port_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_port_id>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_port_id),
            "::",
            stringify!(id)
        )
    );
}
impl rte_flow_action_port_id {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        original: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_meter {
    pub mtr_id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_meter() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_meter>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_meter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_meter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_meter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_meter>())).mtr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_meter),
            "::",
            stringify!(mtr_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_security {
    pub security_session: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_action_security() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_security>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_security))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_security>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_security))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_security>())).security_session as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_security),
            "::",
            stringify!(security_session)
        )
    );
}
impl Default for rte_flow_action_security {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_mpls_ttl {
    pub mpls_ttl: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_mpls_ttl() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_mpls_ttl>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_mpls_ttl))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_mpls_ttl>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_mpls_ttl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_of_set_mpls_ttl>())).mpls_ttl as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_mpls_ttl),
            "::",
            stringify!(mpls_ttl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_nw_ttl {
    pub nw_ttl: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_nw_ttl() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_nw_ttl>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_nw_ttl))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_nw_ttl>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_nw_ttl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_of_set_nw_ttl>())).nw_ttl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_nw_ttl),
            "::",
            stringify!(nw_ttl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_push_vlan {
    pub ethertype: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_push_vlan() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_push_vlan>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_push_vlan))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_push_vlan>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_push_vlan))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_of_push_vlan>())).ethertype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_push_vlan),
            "::",
            stringify!(ethertype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_vlan_vid {
    pub vlan_vid: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_vlan_vid() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_vlan_vid>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_vlan_vid))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_vlan_vid>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_vlan_vid))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_of_set_vlan_vid>())).vlan_vid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_vlan_vid),
            "::",
            stringify!(vlan_vid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_vlan_pcp {
    pub vlan_pcp: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_vlan_pcp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_vlan_pcp>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_vlan_pcp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_vlan_pcp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_vlan_pcp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_of_set_vlan_pcp>())).vlan_pcp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_vlan_pcp),
            "::",
            stringify!(vlan_pcp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_pop_mpls {
    pub ethertype: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_pop_mpls() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_pop_mpls>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_pop_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_pop_mpls>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_pop_mpls))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_of_pop_mpls>())).ethertype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_pop_mpls),
            "::",
            stringify!(ethertype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_push_mpls {
    pub ethertype: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_push_mpls() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_push_mpls>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_push_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_push_mpls>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_push_mpls))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_of_push_mpls>())).ethertype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_push_mpls),
            "::",
            stringify!(ethertype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_vxlan_encap {
    pub definition: *mut rte_flow_item,
}
#[test]
fn bindgen_test_layout_rte_flow_action_vxlan_encap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_vxlan_encap>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_vxlan_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_vxlan_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_vxlan_encap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_vxlan_encap>())).definition as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_vxlan_encap),
            "::",
            stringify!(definition)
        )
    );
}
impl Default for rte_flow_action_vxlan_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_nvgre_encap {
    pub definition: *mut rte_flow_item,
}
#[test]
fn bindgen_test_layout_rte_flow_action_nvgre_encap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_nvgre_encap>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_nvgre_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_nvgre_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_nvgre_encap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_nvgre_encap>())).definition as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_nvgre_encap),
            "::",
            stringify!(definition)
        )
    );
}
impl Default for rte_flow_action_nvgre_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_raw_encap {
    pub data: *mut u8,
    pub preserve: *mut u8,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_raw_encap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_raw_encap>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_action_raw_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_raw_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_raw_encap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_encap>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_encap),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_raw_encap>())).preserve as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_encap),
            "::",
            stringify!(preserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_encap>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_encap),
            "::",
            stringify!(size)
        )
    );
}
impl Default for rte_flow_action_raw_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_raw_decap {
    pub data: *mut u8,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_raw_decap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_raw_decap>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action_raw_decap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_raw_decap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_raw_decap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_decap>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_decap),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_decap>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_decap),
            "::",
            stringify!(size)
        )
    );
}
impl Default for rte_flow_action_raw_decap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_ipv4 {
    pub ipv4_addr: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_ipv4>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_ipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_ipv4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_set_ipv4>())).ipv4_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_ipv4),
            "::",
            stringify!(ipv4_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_ipv6 {
    pub ipv6_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_ipv6() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_ipv6>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_ipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_ipv6>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_ipv6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_set_ipv6>())).ipv6_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_ipv6),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_tp {
    pub port: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_tp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_tp>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_tp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_tp>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_tp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tp>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tp),
            "::",
            stringify!(port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_ttl {
    pub ttl_value: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_ttl() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_ttl>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_ttl))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_ttl>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_ttl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_set_ttl>())).ttl_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_ttl),
            "::",
            stringify!(ttl_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_mac {
    pub mac_addr: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_mac() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_mac>(),
        6usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_mac))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_mac>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_mac))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_action_set_mac>())).mac_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_mac),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_tag {
    pub data: u32,
    pub mask: u32,
    pub index: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_tag() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_tag>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tag>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tag),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tag>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tag),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tag>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tag),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_meta {
    pub data: u32,
    pub mask: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_meta() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_meta>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_meta>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_meta>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_meta),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_meta>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_meta),
            "::",
            stringify!(mask)
        )
    );
}
extern "C" {
    pub static mut rte_flow_dynf_metadata_offs: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rte_flow_dynf_metadata_mask: u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action {
    pub type_: rte_flow_action_type::Type,
    pub conf: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_action() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action>())).conf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action),
            "::",
            stringify!(conf)
        )
    );
}
impl Default for rte_flow_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
pub mod rte_flow_error_type {
    pub type Type = u32;
    pub const RTE_FLOW_ERROR_TYPE_NONE: Type = 0;
    pub const RTE_FLOW_ERROR_TYPE_UNSPECIFIED: Type = 1;
    pub const RTE_FLOW_ERROR_TYPE_HANDLE: Type = 2;
    pub const RTE_FLOW_ERROR_TYPE_ATTR_GROUP: Type = 3;
    pub const RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY: Type = 4;
    pub const RTE_FLOW_ERROR_TYPE_ATTR_INGRESS: Type = 5;
    pub const RTE_FLOW_ERROR_TYPE_ATTR_EGRESS: Type = 6;
    pub const RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER: Type = 7;
    pub const RTE_FLOW_ERROR_TYPE_ATTR: Type = 8;
    pub const RTE_FLOW_ERROR_TYPE_ITEM_NUM: Type = 9;
    pub const RTE_FLOW_ERROR_TYPE_ITEM_SPEC: Type = 10;
    pub const RTE_FLOW_ERROR_TYPE_ITEM_LAST: Type = 11;
    pub const RTE_FLOW_ERROR_TYPE_ITEM_MASK: Type = 12;
    pub const RTE_FLOW_ERROR_TYPE_ITEM: Type = 13;
    pub const RTE_FLOW_ERROR_TYPE_ACTION_NUM: Type = 14;
    pub const RTE_FLOW_ERROR_TYPE_ACTION_CONF: Type = 15;
    pub const RTE_FLOW_ERROR_TYPE_ACTION: Type = 16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_error {
    pub type_: rte_flow_error_type::Type,
    pub cause: *const ::std::os::raw::c_void,
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_flow_error() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_error>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_error>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_error),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_error>())).cause as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_error),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_error>())).message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_error),
            "::",
            stringify!(message)
        )
    );
}
impl Default for rte_flow_error {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_conv_rule {
    pub __bindgen_anon_1: rte_flow_conv_rule__bindgen_ty_1,
    pub __bindgen_anon_2: rte_flow_conv_rule__bindgen_ty_2,
    pub __bindgen_anon_3: rte_flow_conv_rule__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_1 {
    pub attr_ro: *const rte_flow_attr,
    pub attr: *mut rte_flow_attr,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_flow_conv_rule__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_1>())).attr_ro as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_1),
            "::",
            stringify!(attr_ro)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_1>())).attr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_1),
            "::",
            stringify!(attr)
        )
    );
}
impl Default for rte_flow_conv_rule__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_2 {
    pub pattern_ro: *const rte_flow_item,
    pub pattern: *mut rte_flow_item,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_flow_conv_rule__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_2>())).pattern_ro as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_2),
            "::",
            stringify!(pattern_ro)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_2>())).pattern as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_2),
            "::",
            stringify!(pattern)
        )
    );
}
impl Default for rte_flow_conv_rule__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_3 {
    pub actions_ro: *const rte_flow_action,
    pub actions: *mut rte_flow_action,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_flow_conv_rule__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_3>())).actions_ro as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_3),
            "::",
            stringify!(actions_ro)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_3>())).actions as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_3),
            "::",
            stringify!(actions)
        )
    );
}
impl Default for rte_flow_conv_rule__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_conv_rule))
    );
}
impl Default for rte_flow_conv_rule {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_flow_conv_op {
    pub type Type = u32;
    pub const RTE_FLOW_CONV_OP_NONE: Type = 0;
    pub const RTE_FLOW_CONV_OP_ATTR: Type = 1;
    pub const RTE_FLOW_CONV_OP_ITEM: Type = 2;
    pub const RTE_FLOW_CONV_OP_ACTION: Type = 3;
    pub const RTE_FLOW_CONV_OP_PATTERN: Type = 4;
    pub const RTE_FLOW_CONV_OP_ACTIONS: Type = 5;
    pub const RTE_FLOW_CONV_OP_RULE: Type = 6;
    pub const RTE_FLOW_CONV_OP_ITEM_NAME: Type = 7;
    pub const RTE_FLOW_CONV_OP_ACTION_NAME: Type = 8;
    pub const RTE_FLOW_CONV_OP_ITEM_NAME_PTR: Type = 9;
    pub const RTE_FLOW_CONV_OP_ACTION_NAME_PTR: Type = 10;
}
extern "C" {
    pub fn rte_flow_dynf_metadata_register() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_flow_validate(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_flow_create(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
extern "C" {
    pub fn rte_flow_destroy(
        port_id: u16,
        flow: *mut rte_flow,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_flow_flush(port_id: u16, error: *mut rte_flow_error) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_flow_query(
        port_id: u16,
        flow: *mut rte_flow,
        action: *const rte_flow_action,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_flow_isolate(
        port_id: u16,
        set: ::std::os::raw::c_int,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_flow_error_set(
        error: *mut rte_flow_error,
        code: ::std::os::raw::c_int,
        type_: rte_flow_error_type::Type,
        cause: *const ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct rte_flow_desc {
    pub size: size_t,
    pub attr: rte_flow_attr,
    pub items: *mut rte_flow_item,
    pub actions: *mut rte_flow_action,
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_rte_flow_desc() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_desc>(),
        40usize,
        concat!("Size of: ", stringify!(rte_flow_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_desc))
    );
}
impl Default for rte_flow_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_flow_copy(
        fd: *mut rte_flow_desc,
        len: size_t,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
    ) -> size_t;
}
extern "C" {
    pub fn rte_flow_conv(
        op: rte_flow_conv_op::Type,
        dst: *mut ::std::os::raw::c_void,
        size: size_t,
        src: *const ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_filter_type {
    pub type Type = u32;
    pub const RTE_ETH_FILTER_NONE: Type = 0;
    pub const RTE_ETH_FILTER_MACVLAN: Type = 1;
    pub const RTE_ETH_FILTER_ETHERTYPE: Type = 2;
    pub const RTE_ETH_FILTER_FLEXIBLE: Type = 3;
    pub const RTE_ETH_FILTER_SYN: Type = 4;
    pub const RTE_ETH_FILTER_NTUPLE: Type = 5;
    pub const RTE_ETH_FILTER_TUNNEL: Type = 6;
    pub const RTE_ETH_FILTER_FDIR: Type = 7;
    pub const RTE_ETH_FILTER_HASH: Type = 8;
    pub const RTE_ETH_FILTER_L2_TUNNEL: Type = 9;
    pub const RTE_ETH_FILTER_GENERIC: Type = 10;
    pub const RTE_ETH_FILTER_MAX: Type = 11;
}
pub mod rte_filter_op {
    pub type Type = u32;
    pub const RTE_ETH_FILTER_NOP: Type = 0;
    pub const RTE_ETH_FILTER_ADD: Type = 1;
    pub const RTE_ETH_FILTER_UPDATE: Type = 2;
    pub const RTE_ETH_FILTER_DELETE: Type = 3;
    pub const RTE_ETH_FILTER_FLUSH: Type = 4;
    pub const RTE_ETH_FILTER_GET: Type = 5;
    pub const RTE_ETH_FILTER_SET: Type = 6;
    pub const RTE_ETH_FILTER_INFO: Type = 7;
    pub const RTE_ETH_FILTER_STATS: Type = 8;
    pub const RTE_ETH_FILTER_OP_MAX: Type = 9;
}
pub mod rte_mac_filter_type {
    pub type Type = u32;
    pub const RTE_MAC_PERFECT_MATCH: Type = 1;
    pub const RTE_MACVLAN_PERFECT_MATCH: Type = 2;
    pub const RTE_MAC_HASH_MATCH: Type = 3;
    pub const RTE_MACVLAN_HASH_MATCH: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_mac_filter {
    pub is_vf: u8,
    pub dst_id: u16,
    pub filter_type: rte_mac_filter_type::Type,
    pub mac_addr: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_filter>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).is_vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).dst_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(dst_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).filter_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(mac_addr)
        )
    );
}
impl Default for rte_eth_mac_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ethertype_filter {
    pub mac_addr: rte_ether_addr,
    pub ether_type: u16,
    pub flags: u16,
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ethertype_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ethertype_filter>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ethertype_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).mac_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).ether_type as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).queue as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_flex_filter {
    pub len: u16,
    pub bytes: [u8; 128usize],
    pub mask: [u8; 16usize],
    pub priority: u8,
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_flex_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_filter>(),
        150usize,
        concat!("Size of: ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).mask as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).priority as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).queue as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(queue)
        )
    );
}
impl Default for rte_eth_flex_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_syn_filter {
    pub hig_pri: u8,
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_syn_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_syn_filter>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_syn_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).hig_pri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(hig_pri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ntuple_filter {
    pub flags: u16,
    pub dst_ip: u32,
    pub dst_ip_mask: u32,
    pub src_ip: u32,
    pub src_ip_mask: u32,
    pub dst_port: u16,
    pub dst_port_mask: u16,
    pub src_port: u16,
    pub src_port_mask: u16,
    pub proto: u8,
    pub proto_mask: u8,
    pub tcp_flags: u8,
    pub priority: u16,
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ntuple_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ntuple_filter>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ntuple_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port_mask as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port_mask as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto_mask as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).tcp_flags as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).priority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).queue as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(queue)
        )
    );
}
pub mod rte_tunnel_iptype {
    pub type Type = u32;
    pub const RTE_TUNNEL_IPTYPE_IPV4: Type = 0;
    pub const RTE_TUNNEL_IPTYPE_IPV6: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tunnel_filter_conf {
    pub outer_mac: rte_ether_addr,
    pub inner_mac: rte_ether_addr,
    pub inner_vlan: u16,
    pub ip_type: rte_tunnel_iptype::Type,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    pub filter_type: u16,
    pub tunnel_type: rte_eth_tunnel_type::Type,
    pub tenant_id: u32,
    pub queue_id: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    pub ipv4_addr: u32,
    pub ipv6_addr: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv4_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv4_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv6_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
impl Default for rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf>(),
        52usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).outer_mac as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(outer_mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_mac as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_vlan as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_vlan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_addr as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).filter_type as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tunnel_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tenant_id as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tenant_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).queue_id as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(queue_id)
        )
    );
}
impl Default for rte_eth_tunnel_filter_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_global_cfg_type {
    pub type Type = u32;
    pub const RTE_ETH_GLOBAL_CFG_TYPE_UNKNOWN: Type = 0;
    pub const RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN: Type = 1;
    pub const RTE_ETH_GLOBAL_CFG_TYPE_MAX: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_global_cfg {
    pub cfg_type: rte_eth_global_cfg_type::Type,
    pub cfg: rte_eth_global_cfg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_global_cfg__bindgen_ty_1 {
    pub gre_key_len: u8,
    pub reserved: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).gre_key_len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(gre_key_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for rte_eth_global_cfg__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg)
        )
    );
}
impl Default for rte_eth_global_cfg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_input_set_field {
    pub type Type = u32;
    pub const RTE_ETH_INPUT_SET_UNKNOWN: Type = 0;
    pub const RTE_ETH_INPUT_SET_L2_SRC_MAC: Type = 1;
    pub const RTE_ETH_INPUT_SET_L2_DST_MAC: Type = 2;
    pub const RTE_ETH_INPUT_SET_L2_OUTER_VLAN: Type = 3;
    pub const RTE_ETH_INPUT_SET_L2_INNER_VLAN: Type = 4;
    pub const RTE_ETH_INPUT_SET_L2_ETHERTYPE: Type = 5;
    pub const RTE_ETH_INPUT_SET_L3_SRC_IP4: Type = 129;
    pub const RTE_ETH_INPUT_SET_L3_DST_IP4: Type = 130;
    pub const RTE_ETH_INPUT_SET_L3_SRC_IP6: Type = 131;
    pub const RTE_ETH_INPUT_SET_L3_DST_IP6: Type = 132;
    pub const RTE_ETH_INPUT_SET_L3_IP4_TOS: Type = 133;
    pub const RTE_ETH_INPUT_SET_L3_IP4_PROTO: Type = 134;
    pub const RTE_ETH_INPUT_SET_L3_IP6_TC: Type = 135;
    pub const RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER: Type = 136;
    pub const RTE_ETH_INPUT_SET_L3_IP4_TTL: Type = 137;
    pub const RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS: Type = 138;
    pub const RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT: Type = 257;
    pub const RTE_ETH_INPUT_SET_L4_UDP_DST_PORT: Type = 258;
    pub const RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT: Type = 259;
    pub const RTE_ETH_INPUT_SET_L4_TCP_DST_PORT: Type = 260;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT: Type = 261;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT: Type = 262;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG: Type = 263;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC: Type = 385;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC: Type = 386;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN: Type = 387;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY: Type = 388;
    pub const RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY: Type = 389;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD: Type = 641;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD: Type = 642;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD: Type = 643;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD: Type = 644;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD: Type = 645;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD: Type = 646;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD: Type = 647;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD: Type = 648;
    pub const RTE_ETH_INPUT_SET_DEFAULT: Type = 65533;
    pub const RTE_ETH_INPUT_SET_NONE: Type = 65534;
    pub const RTE_ETH_INPUT_SET_MAX: Type = 65535;
}
pub mod rte_filter_input_set_op {
    pub type Type = u32;
    pub const RTE_ETH_INPUT_SET_OP_UNKNOWN: Type = 0;
    pub const RTE_ETH_INPUT_SET_SELECT: Type = 1;
    pub const RTE_ETH_INPUT_SET_ADD: Type = 2;
    pub const RTE_ETH_INPUT_SET_OP_MAX: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field::Type; 128usize],
    pub op: rte_filter_input_set_op::Type,
}
#[test]
fn bindgen_test_layout_rte_eth_input_set_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_input_set_conf>(),
        520usize,
        concat!("Size of: ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_input_set_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_input_set_conf>())).flow_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_input_set_conf>())).inset_size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(inset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).field as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).op as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(op)
        )
    );
}
impl Default for rte_eth_input_set_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_l2_flow {
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Size of: ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_flow>())).ether_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_flow),
            "::",
            stringify!(ether_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ipv4_flow {
    pub src_ip: u32,
    pub dst_ip: u32,
    pub tos: u8,
    pub ttl: u8,
    pub proto: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv4_flow>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).tos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).ttl as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).proto as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udpv4_flow {
    pub ip: rte_eth_ipv4_flow,
    pub src_port: u16,
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_tcpv4_flow {
    pub ip: rte_eth_ipv4_flow,
    pub src_port: u16,
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_sctpv4_flow {
    pub ip: rte_eth_ipv4_flow,
    pub src_port: u16,
    pub dst_port: u16,
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv4_flow>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).verify_tag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ipv6_flow {
    pub src_ip: [u32; 4usize],
    pub dst_ip: [u32; 4usize],
    pub tc: u8,
    pub proto: u8,
    pub hop_limits: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv6_flow>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).tc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).proto as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).hop_limits as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(hop_limits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udpv6_flow {
    pub ip: rte_eth_ipv6_flow,
    pub src_port: u16,
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_tcpv6_flow {
    pub ip: rte_eth_ipv6_flow,
    pub src_port: u16,
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_sctpv6_flow {
    pub ip: rte_eth_ipv6_flow,
    pub src_port: u16,
    pub dst_port: u16,
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv6_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).verify_tag as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_mac_vlan_flow {
    pub mac_addr: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_vlan_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_vlan_flow>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_vlan_flow>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_vlan_flow>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_vlan_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
pub mod rte_eth_fdir_tunnel_type {
    pub type Type = u32;
    pub const RTE_FDIR_TUNNEL_TYPE_UNKNOWN: Type = 0;
    pub const RTE_FDIR_TUNNEL_TYPE_NVGRE: Type = 1;
    pub const RTE_FDIR_TUNNEL_TYPE_VXLAN: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_tunnel_flow {
    pub tunnel_type: rte_eth_fdir_tunnel_type::Type,
    pub tunnel_id: u32,
    pub mac_addr: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
impl Default for rte_eth_tunnel_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_flow {
    pub l2_flow: rte_eth_l2_flow,
    pub udp4_flow: rte_eth_udpv4_flow,
    pub tcp4_flow: rte_eth_tcpv4_flow,
    pub sctp4_flow: rte_eth_sctpv4_flow,
    pub ip4_flow: rte_eth_ipv4_flow,
    pub udp6_flow: rte_eth_udpv6_flow,
    pub tcp6_flow: rte_eth_tcpv6_flow,
    pub sctp6_flow: rte_eth_sctpv6_flow,
    pub ipv6_flow: rte_eth_ipv6_flow,
    pub mac_vlan_flow: rte_eth_mac_vlan_flow,
    pub tunnel_flow: rte_eth_tunnel_flow,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).l2_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(l2_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ip4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ip4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ipv6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ipv6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).mac_vlan_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(mac_vlan_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tunnel_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tunnel_flow)
        )
    );
}
impl Default for rte_eth_fdir_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    pub is_vf: u8,
    pub dst_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow_ext>(),
        22usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow_ext>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).flexbytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(flexbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).is_vf as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).dst_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(dst_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_input() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_input>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_input>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_ext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_ext)
        )
    );
}
impl Default for rte_eth_fdir_input {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_fdir_behavior {
    pub type Type = u32;
    pub const RTE_ETH_FDIR_ACCEPT: Type = 0;
    pub const RTE_ETH_FDIR_REJECT: Type = 1;
    pub const RTE_ETH_FDIR_PASSTHRU: Type = 2;
}
pub mod rte_eth_fdir_status {
    pub type Type = u32;
    pub const RTE_ETH_FDIR_NO_REPORT_STATUS: Type = 0;
    pub const RTE_ETH_FDIR_REPORT_ID: Type = 1;
    pub const RTE_ETH_FDIR_REPORT_ID_FLEX_4: Type = 2;
    pub const RTE_ETH_FDIR_REPORT_FLEX_8: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_action {
    pub rx_queue: u16,
    pub behavior: rte_eth_fdir_behavior::Type,
    pub report_status: rte_eth_fdir_status::Type,
    pub flex_off: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_action() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_action>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_action>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).rx_queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(rx_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).behavior as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_action>())).report_status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(report_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).flex_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(flex_off)
        )
    );
}
impl Default for rte_eth_fdir_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    pub input: rte_eth_fdir_input,
    pub action: rte_eth_fdir_action,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter>(),
        92usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).soft_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(soft_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).input as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).action as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(action)
        )
    );
}
impl Default for rte_eth_fdir_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_masks {
    pub vlan_tci_mask: u16,
    pub ipv4_mask: rte_eth_ipv4_flow,
    pub ipv6_mask: rte_eth_ipv6_flow,
    pub src_port_mask: u16,
    pub dst_port_mask: u16,
    pub mac_addr_byte_mask: u8,
    pub tunnel_id_mask: u32,
    pub tunnel_type_mask: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_masks() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_masks>(),
        68usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_masks>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).vlan_tci_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(vlan_tci_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv4_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv4_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv6_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv6_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).src_port_mask as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).dst_port_mask as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).mac_addr_byte_mask as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(mac_addr_byte_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_id_mask as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_id_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_type_mask as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_type_mask)
        )
    );
}
pub mod rte_eth_payload_type {
    pub type Type = u32;
    pub const RTE_ETH_PAYLOAD_UNKNOWN: Type = 0;
    pub const RTE_ETH_RAW_PAYLOAD: Type = 1;
    pub const RTE_ETH_L2_PAYLOAD: Type = 2;
    pub const RTE_ETH_L3_PAYLOAD: Type = 3;
    pub const RTE_ETH_L4_PAYLOAD: Type = 4;
    pub const RTE_ETH_PAYLOAD_MAX: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_flex_payload_cfg {
    pub type_: rte_eth_payload_type::Type,
    pub src_offset: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_flex_payload_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_payload_cfg>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_payload_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).src_offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(src_offset)
        )
    );
}
impl Default for rte_eth_flex_payload_cfg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_mask() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_mask>(),
        18usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_mask>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).flow_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).mask as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flex_conf {
    pub nb_payloads: u16,
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 24usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_conf>(),
        724usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_payloads as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_payloads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_flexmasks as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_flexmasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_set as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_mask as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_mask)
        )
    );
}
impl Default for rte_eth_fdir_flex_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_fdir_mode {
    pub type Type = u32;
    pub const RTE_FDIR_MODE_NONE: Type = 0;
    pub const RTE_FDIR_MODE_SIGNATURE: Type = 1;
    pub const RTE_FDIR_MODE_PERFECT: Type = 2;
    pub const RTE_FDIR_MODE_PERFECT_MAC_VLAN: Type = 3;
    pub const RTE_FDIR_MODE_PERFECT_TUNNEL: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_info {
    pub mode: rte_fdir_mode::Type,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
    pub guarant_spc: u32,
    pub best_spc: u32,
    pub flow_types_mask: [u64; 1usize],
    pub max_flexpayload: u32,
    pub flex_payload_unit: u32,
    pub max_flex_payload_segment_num: u32,
    pub flex_payload_limit: u16,
    pub flex_bitmask_unit: u32,
    pub max_flex_bitmask_num: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_info>(),
        840usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_conf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).guarant_spc as *const _ as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(guarant_spc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).best_spc as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(best_spc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flow_types_mask as *const _ as usize
        },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flow_types_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flexpayload as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flexpayload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_unit as *const _ as usize
        },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_payload_segment_num as *const _
                as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_payload_segment_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_limit as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_bitmask_unit as *const _ as usize
        },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_bitmask_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_bitmask_num as *const _ as usize
        },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_bitmask_num)
        )
    );
}
impl Default for rte_eth_fdir_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_stats {
    pub collision: u32,
    pub free: u32,
    pub maxhash: u32,
    pub maxlen: u32,
    pub add: u64,
    pub remove: u64,
    pub f_add: u64,
    pub f_remove: u64,
    pub guarant_cnt: u32,
    pub best_cnt: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_stats>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).collision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(collision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).free as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxhash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).add as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).remove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_add as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_remove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).guarant_cnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(guarant_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).best_cnt as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(best_cnt)
        )
    );
}
pub mod rte_eth_fdir_filter_info_type {
    pub type Type = u32;
    pub const RTE_ETH_FDIR_FILTER_INFO_TYPE_UNKNOWN: Type = 0;
    pub const RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT: Type = 1;
    pub const RTE_ETH_FDIR_FILTER_INFO_TYPE_MAX: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter_info {
    pub info_type: rte_eth_fdir_filter_info_type::Type,
    pub info: rte_eth_fdir_filter_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_filter_info__bindgen_ty_1 {
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        520usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_filter_info__bindgen_ty_1>())).input_set_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
impl Default for rte_eth_fdir_filter_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info>(),
        524usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info)
        )
    );
}
impl Default for rte_eth_fdir_filter_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_hash_filter_info_type {
    pub type Type = u32;
    pub const RTE_ETH_HASH_FILTER_INFO_TYPE_UNKNOWN: Type = 0;
    pub const RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT: Type = 1;
    pub const RTE_ETH_HASH_FILTER_GLOBAL_CONFIG: Type = 2;
    pub const RTE_ETH_HASH_FILTER_INPUT_SET_SELECT: Type = 3;
    pub const RTE_ETH_HASH_FILTER_INFO_TYPE_MAX: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_hash_global_conf {
    pub hash_func: rte_eth_hash_function::Type,
    pub sym_hash_enable_mask: [u64; 1usize],
    pub valid_bit_mask: [u64; 1usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_global_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_global_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_global_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).hash_func as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(hash_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).sym_hash_enable_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(sym_hash_enable_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).valid_bit_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(valid_bit_mask)
        )
    );
}
impl Default for rte_eth_hash_global_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hash_filter_info {
    pub info_type: rte_eth_hash_filter_info_type::Type,
    pub info: rte_eth_hash_filter_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_hash_filter_info__bindgen_ty_1 {
    pub enable: u8,
    pub global_conf: rte_eth_hash_global_conf,
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u64; 65usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        520usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).enable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).global_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(global_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).input_set_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
impl Default for rte_eth_hash_filter_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info>(),
        528usize,
        concat!("Size of: ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info)
        )
    );
}
impl Default for rte_eth_hash_filter_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_l2_tunnel_conf {
    pub l2_tunnel_type: rte_eth_tunnel_type::Type,
    pub ether_type: u16,
    pub tunnel_id: u32,
    pub vf_id: u16,
    pub pool: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_tunnel_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_tunnel_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_tunnel_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).l2_tunnel_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(l2_tunnel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).ether_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).tunnel_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).vf_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(vf_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(pool)
        )
    );
}
impl Default for rte_eth_l2_tunnel_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_fdir_pballoc_type {
    pub type Type = u32;
    pub const RTE_FDIR_PBALLOC_64K: Type = 0;
    pub const RTE_FDIR_PBALLOC_128K: Type = 1;
    pub const RTE_FDIR_PBALLOC_256K: Type = 2;
}
pub mod rte_fdir_status_mode {
    pub type Type = u32;
    pub const RTE_FDIR_NO_REPORT_STATUS: Type = 0;
    pub const RTE_FDIR_REPORT_STATUS: Type = 1;
    pub const RTE_FDIR_REPORT_STATUS_ALWAYS: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_fdir_conf {
    pub mode: rte_fdir_mode::Type,
    pub pballoc: rte_fdir_pballoc_type::Type,
    pub status: rte_fdir_status_mode::Type,
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[test]
fn bindgen_test_layout_rte_fdir_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_fdir_conf>(),
        808usize,
        concat!("Size of: ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fdir_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).pballoc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(pballoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).drop_queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(drop_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).flex_conf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(flex_conf)
        )
    );
}
impl Default for rte_fdir_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udp_tunnel {
    pub udp_port: u16,
    pub prot_type: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_udp_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udp_tunnel>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udp_tunnel>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).udp_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(udp_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).prot_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(prot_type)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_intr_conf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_intr_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_conf))
    );
}
impl rte_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    pub link_speeds: u32,
    pub rxmode: rte_eth_rxmode,
    pub txmode: rte_eth_txmode,
    pub lpbk_mode: u32,
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    pub dcb_capability_en: u32,
    pub fdir_conf: rte_fdir_conf,
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>(),
        2120usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).rss_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(rss_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_dcb_conf as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_dcb_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).dcb_rx_conf as *const _ as usize
        },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(dcb_rx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_rx_conf as *const _ as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_rx_conf)
        )
    );
}
impl Default for rte_eth_conf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_dcb_tx_conf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).dcb_tx_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_tx_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_tx_conf)
        )
    );
}
impl Default for rte_eth_conf__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf>(),
        3080usize,
        concat!("Size of: ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).link_speeds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(link_speeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rxmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rxmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).txmode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(txmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).lpbk_mode as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(lpbk_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rx_adv_conf as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).tx_adv_conf as *const _ as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(tx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).dcb_capability_en as *const _ as usize },
        2260usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(dcb_capability_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).fdir_conf as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(fdir_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).intr_conf as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(intr_conf)
        )
    );
}
impl Default for rte_eth_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_portconf {
    pub burst_size: u16,
    pub ring_size: u16,
    pub nb_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_portconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_portconf>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_portconf>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).burst_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(burst_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).ring_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).nb_queues as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(nb_queues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_switch_info {
    pub name: *const ::std::os::raw::c_char,
    pub domain_id: u16,
    pub port_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_switch_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_switch_info>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_switch_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).domain_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).port_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(port_id)
        )
    );
}
impl Default for rte_eth_switch_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_info {
    pub device: *mut rte_device,
    pub driver_name: *const ::std::os::raw::c_char,
    pub if_index: ::std::os::raw::c_uint,
    pub min_mtu: u16,
    pub max_mtu: u16,
    pub dev_flags: *const u32,
    pub min_rx_bufsize: u32,
    pub max_rx_pktlen: u32,
    pub max_lro_pkt_size: u32,
    pub max_rx_queues: u16,
    pub max_tx_queues: u16,
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    pub max_vfs: u16,
    pub max_vmdq_pools: u16,
    pub rx_offload_capa: u64,
    pub tx_offload_capa: u64,
    pub rx_queue_offload_capa: u64,
    pub tx_queue_offload_capa: u64,
    pub reta_size: u16,
    pub hash_key_size: u8,
    pub flow_type_rss_offloads: u64,
    pub default_rxconf: rte_eth_rxconf,
    pub default_txconf: rte_eth_txconf,
    pub vmdq_queue_base: u16,
    pub vmdq_queue_num: u16,
    pub vmdq_pool_base: u16,
    pub rx_desc_lim: rte_eth_desc_lim,
    pub tx_desc_lim: rte_eth_desc_lim,
    pub speed_capa: u32,
    pub nb_rx_queues: u16,
    pub nb_tx_queues: u16,
    pub default_rxportconf: rte_eth_dev_portconf,
    pub default_txportconf: rte_eth_dev_portconf,
    pub dev_capa: u64,
    pub switch_info: rte_eth_switch_info,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_info>(),
        320usize,
        concat!("Size of: ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).driver_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(driver_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).if_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(if_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).min_mtu as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_mtu as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).min_rx_bufsize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_rx_bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_pktlen as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_pktlen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).max_lro_pkt_size as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_lro_pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_queues as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_tx_queues as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_mac_addrs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mac_addrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).max_hash_mac_addrs as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vfs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vmdq_pools as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vmdq_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_offload_capa as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_offload_capa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_offload_capa as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_offload_capa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_queue_offload_capa as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_queue_offload_capa as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reta_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reta_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).hash_key_size as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(hash_key_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).flow_type_rss_offloads as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(flow_type_rss_offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxconf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txconf as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txconf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_base as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_num as *const _ as usize },
        218usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_pool_base as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_pool_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_desc_lim as *const _ as usize },
        222usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_desc_lim as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).speed_capa as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(speed_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_rx_queues as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_tx_queues as *const _ as usize },
        250usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxportconf as *const _ as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxportconf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txportconf as *const _ as usize
        },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txportconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_capa as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).switch_info as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(switch_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reserved_64s as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reserved_ptrs as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_dev_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxq_info {
    pub mp: *mut rte_mempool,
    pub conf: rte_eth_rxconf,
    pub scattered_rx: u8,
    pub nb_desc: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_rxq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxq_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxq_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).mp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).conf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).scattered_rx as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(scattered_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).nb_desc as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
impl Default for rte_eth_rxq_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_txq_info {
    pub conf: rte_eth_txconf,
    pub nb_desc: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_txq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txq_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txq_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).nb_desc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
impl Default for rte_eth_txq_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_burst_mode {
    pub flags: u64,
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_rte_eth_burst_mode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_burst_mode>(),
        1032usize,
        concat!("Size of: ", stringify!(rte_eth_burst_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_burst_mode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_burst_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_burst_mode>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_burst_mode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_burst_mode>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_burst_mode),
            "::",
            stringify!(info)
        )
    );
}
impl Default for rte_eth_burst_mode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_xstat {
    pub id: u64,
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_xstat() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_xstat_name() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat_name>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat_name>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat_name>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat_name),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_eth_xstat_name {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).nb_queue
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).nb_queue
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>(),
        2048usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_rxq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_rxq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_txq as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_txq)
        )
    );
}
impl Default for rte_eth_dcb_tc_queue_mapping {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    pub nb_tcs: u8,
    pub prio_tc: [u8; 8usize],
    pub tc_bws: [u8; 8usize],
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_info>(),
        2065usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).prio_tc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(prio_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_bws as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_bws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_queue as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_queue)
        )
    );
}
impl Default for rte_eth_dcb_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
pub mod rte_eth_dev_state {
    pub type Type = u32;
    pub const RTE_ETH_DEV_UNUSED: Type = 0;
    pub const RTE_ETH_DEV_ATTACHED: Type = 1;
    pub const RTE_ETH_DEV_REMOVED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_sriov {
    pub active: u8,
    pub nb_q_per_pool: u8,
    pub def_vmdq_idx: u16,
    pub def_pool_q_idx: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_sriov() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_sriov>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_sriov>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).nb_q_per_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(nb_q_per_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_vmdq_idx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_vmdq_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_pool_q_idx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_pool_q_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_owner {
    pub id: u64,
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_owner() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_owner>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_owner>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_owner),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_owner),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_eth_dev_owner {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_eth_find_next_owned_by(port_id: u16, owner_id: u64) -> u64;
}
extern "C" {
    pub fn rte_eth_find_next(port_id: u16) -> u16;
}
extern "C" {
    pub fn rte_eth_find_next_of(port_id_start: u16, parent: *const rte_device) -> u16;
}
extern "C" {
    pub fn rte_eth_find_next_sibling(port_id_start: u16, ref_port_id: u16) -> u16;
}
extern "C" {
    pub fn rte_eth_dev_owner_new(owner_id: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_owner_set(
        port_id: u16,
        owner: *const rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_owner_unset(port_id: u16, owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_owner_delete(owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_owner_get(
        port_id: u16,
        owner: *mut rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_count_avail() -> u16;
}
extern "C" {
    pub fn rte_eth_dev_count_total() -> u16;
}
extern "C" {
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    pub fn rte_eth_dev_rx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_eth_dev_tx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_is_removed(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_rx_hairpin_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_tx_hairpin_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_is_valid_port(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rx_queue_start(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rx_queue_stop(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_tx_queue_start(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_tx_queue_stop(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_stop(port_id: u16);
}
extern "C" {
    pub fn rte_eth_dev_set_link_up(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_link_down(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_close(port_id: u16);
}
extern "C" {
    pub fn rte_eth_dev_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_promiscuous_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_promiscuous_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_promiscuous_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_allmulticast_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_allmulticast_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_allmulticast_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_link_get(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_link_get_nowait(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_stats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_xstats_get_names(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_xstats_get(
        port_id: u16,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_xstats_get_by_id(
        port_id: u16,
        ids: *const u64,
        values: *mut u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u16,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_xstats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u16,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u16,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_macaddr_get(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_info_get(
        port_id: u16,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_fw_version_get(
        port_id: u16,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u16,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_ptypes(
        port_id: u16,
        ptype_mask: u32,
        set_ptypes: *mut u32,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_mtu(port_id: u16, mtu: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_mtu(port_id: u16, mtu: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_vlan_filter(
        port_id: u16,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u16,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u16,
        vlan_type: rte_vlan_type::Type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_vlan_offload(
        port_id: u16,
        offload_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_vlan_offload(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_vlan_pvid(
        port_id: u16,
        pvid: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(
        unsent: *mut *mut rte_mbuf,
        count: u16,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    pub size: u16,
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_tx_buffer() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_tx_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_dev_tx_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_tx_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_tx_buffer))
    );
}
impl Default for rte_eth_dev_tx_buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn rte_eth_tx_buffer_init(
        buffer: *mut rte_eth_dev_tx_buffer,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn rte_eth_tx_done_cleanup(
        port_id: u16,
        queue_id: u16,
        free_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_eth_event_ipsec_subtype {
    pub type Type = u32;
    pub const RTE_ETH_EVENT_IPSEC_UNKNOWN: Type = 0;
    pub const RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW: Type = 1;
    pub const RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY: Type = 2;
    pub const RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY: Type = 3;
    pub const RTE_ETH_EVENT_IPSEC_MAX: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_event_ipsec_desc {
    pub subtype: rte_eth_event_ipsec_subtype::Type,
    pub metadata: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_event_ipsec_desc() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_event_ipsec_desc>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_event_ipsec_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_event_ipsec_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_event_ipsec_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_event_ipsec_desc>())).subtype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_event_ipsec_desc),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_event_ipsec_desc>())).metadata as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_event_ipsec_desc),
            "::",
            stringify!(metadata)
        )
    );
}
impl Default for rte_eth_event_ipsec_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_event_type {
    pub type Type = u32;
    pub const RTE_ETH_EVENT_UNKNOWN: Type = 0;
    pub const RTE_ETH_EVENT_INTR_LSC: Type = 1;
    pub const RTE_ETH_EVENT_QUEUE_STATE: Type = 2;
    pub const RTE_ETH_EVENT_INTR_RESET: Type = 3;
    pub const RTE_ETH_EVENT_VF_MBOX: Type = 4;
    pub const RTE_ETH_EVENT_MACSEC: Type = 5;
    pub const RTE_ETH_EVENT_INTR_RMV: Type = 6;
    pub const RTE_ETH_EVENT_NEW: Type = 7;
    pub const RTE_ETH_EVENT_DESTROY: Type = 8;
    pub const RTE_ETH_EVENT_IPSEC: Type = 9;
    pub const RTE_ETH_EVENT_MAX: Type = 10;
}
pub type rte_eth_dev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_eth_dev_callback_register(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_callback_unregister(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rx_intr_enable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rx_intr_disable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rx_intr_ctl(
        port_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rx_intr_ctl_q(
        port_id: u16,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rx_intr_ctl_q_get_fd(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_led_on(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_led_off(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_flow_ctrl_get(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_flow_ctrl_set(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_priority_flow_ctrl_set(
        port_id: u16,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_mac_addr_add(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
        pool: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_mac_addr_remove(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_default_mac_addr_set(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rss_reta_update(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rss_reta_query(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_uc_hash_table_set(
        port_id: u16,
        addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_uc_all_hash_table_set(port_id: u16, on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_mirror_rule_set(
        port_id: u16,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_mirror_rule_reset(port_id: u16, rule_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_set_queue_rate_limit(
        port_id: u16,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rss_hash_update(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_rss_hash_conf_get(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_udp_tunnel_port_add(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_udp_tunnel_port_delete(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_filter_supported(
        port_id: u16,
        filter_type: rte_filter_type::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_filter_ctrl(
        port_id: u16,
        filter_type: rte_filter_type::Type,
        filter_op: rte_filter_op::Type,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_dcb_info(
        port_id: u16,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_add_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    pub fn rte_eth_add_first_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    pub fn rte_eth_add_tx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_tx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    pub fn rte_eth_remove_rx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_remove_tx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_rx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_rxq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_tx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_txq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_rx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_tx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_reg_info(
        port_id: u16,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_eeprom_length(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_module_info(
        port_id: u16,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_module_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_set_mc_addr_list(
        port_id: u16,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_timesync_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_timesync_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_timesync_read_rx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_timesync_read_tx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_timesync_adjust_time(port_id: u16, delta: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_timesync_read_time(port_id: u16, time: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_timesync_write_time(
        port_id: u16,
        time: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_read_clock(port_id: u16, clock: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_l2_tunnel_eth_type_conf(
        port_id: u16,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_l2_tunnel_offload_set(
        port_id: u16,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_port_by_name(
        name: *const ::std::os::raw::c_char,
        port_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_name_by_port(
        port_id: u16,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(
        port_id: u16,
        nb_rx_desc: *mut u16,
        nb_tx_desc: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_pool_ops_supported(
        port_id: u16,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eth_dev_get_sec_ctx(port_id: u16) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_eth_dev_hairpin_capability_get(
        port_id: u16,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_cb_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_cb_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_cb_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for rte_eth_dev_cb_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_stop_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_close_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_is_removed_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_link_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wait_to_complete: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_stats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        igb_stats: *mut rte_eth_stats,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_names_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        ids: *const u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stats_mapping_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        stat_idx: u8,
        is_rx: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_infos_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_supported_ptypes_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> *const u32>;
pub type eth_dev_ptypes_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, ptype_mask: u32) -> ::std::os::raw::c_int,
>;
pub type eth_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_rx_enable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_disable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(queue: *mut ::std::os::raw::c_void)>;
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> u32>;
pub type eth_rx_descriptor_done_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_fw_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_done_cleanup_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, free_cnt: u32) -> ::std::os::raw::c_int,
>;
pub type eth_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, qinfo: *mut rte_eth_rxq_info),
>;
pub type eth_txq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tx_queue_id: u16, qinfo: *mut rte_eth_txq_info),
>;
pub type eth_burst_mode_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int,
>;
pub type mtu_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int,
>;
pub type vlan_filter_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_tpid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        type_: rte_vlan_type::Type,
        tpid: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_pvid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_strip_queue_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, on: ::std::os::raw::c_int),
>;
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type flow_ctrl_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type priority_flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type reta_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type reta_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type rss_hash_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type rss_hash_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, index: u32)>;
pub type eth_mac_addr_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        index: u32,
        vmdq: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mac_addr_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_uc_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_uc_all_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8) -> ::std::os::raw::c_int,
>;
pub type eth_set_queue_rate_limit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_reset_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rule_id: u8) -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_del_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_set_mc_addr_list_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_read_rx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_tx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_adjust_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_write_time = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *const timespec,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_read_clock = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut u64) -> ::std::os::raw::c_int,
>;
pub type eth_get_reg_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_set_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_module_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_module_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_eth_type_conf_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_filter_ctrl_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        filter_type: rte_filter_type::Type,
        filter_op: rte_filter_op::Type,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tm_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mtr_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_dcb_info = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_pool_ops_supported_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_hairpin_cap_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_rx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        hairpin_conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct eth_dev_ops {
    pub dev_configure: eth_dev_configure_t,
    pub dev_start: eth_dev_start_t,
    pub dev_stop: eth_dev_stop_t,
    pub dev_set_link_up: eth_dev_set_link_up_t,
    pub dev_set_link_down: eth_dev_set_link_down_t,
    pub dev_close: eth_dev_close_t,
    pub dev_reset: eth_dev_reset_t,
    pub link_update: eth_link_update_t,
    pub is_removed: eth_is_removed_t,
    pub promiscuous_enable: eth_promiscuous_enable_t,
    pub promiscuous_disable: eth_promiscuous_disable_t,
    pub allmulticast_enable: eth_allmulticast_enable_t,
    pub allmulticast_disable: eth_allmulticast_disable_t,
    pub mac_addr_remove: eth_mac_addr_remove_t,
    pub mac_addr_add: eth_mac_addr_add_t,
    pub mac_addr_set: eth_mac_addr_set_t,
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    pub mtu_set: mtu_set_t,
    pub stats_get: eth_stats_get_t,
    pub stats_reset: eth_stats_reset_t,
    pub xstats_get: eth_xstats_get_t,
    pub xstats_reset: eth_xstats_reset_t,
    pub xstats_get_names: eth_xstats_get_names_t,
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    pub dev_infos_get: eth_dev_infos_get_t,
    pub rxq_info_get: eth_rxq_info_get_t,
    pub txq_info_get: eth_txq_info_get_t,
    pub rx_burst_mode_get: eth_burst_mode_get_t,
    pub tx_burst_mode_get: eth_burst_mode_get_t,
    pub fw_version_get: eth_fw_version_get_t,
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    pub dev_ptypes_set: eth_dev_ptypes_set_t,
    pub vlan_filter_set: vlan_filter_set_t,
    pub vlan_tpid_set: vlan_tpid_set_t,
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    pub vlan_offload_set: vlan_offload_set_t,
    pub vlan_pvid_set: vlan_pvid_set_t,
    pub rx_queue_start: eth_queue_start_t,
    pub rx_queue_stop: eth_queue_stop_t,
    pub tx_queue_start: eth_queue_start_t,
    pub tx_queue_stop: eth_queue_stop_t,
    pub rx_queue_setup: eth_rx_queue_setup_t,
    pub rx_queue_release: eth_queue_release_t,
    pub rx_queue_count: eth_rx_queue_count_t,
    pub rx_descriptor_done: eth_rx_descriptor_done_t,
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    pub tx_queue_setup: eth_tx_queue_setup_t,
    pub tx_queue_release: eth_queue_release_t,
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    pub dev_led_on: eth_dev_led_on_t,
    pub dev_led_off: eth_dev_led_off_t,
    pub flow_ctrl_get: flow_ctrl_get_t,
    pub flow_ctrl_set: flow_ctrl_set_t,
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    pub mirror_rule_set: eth_mirror_rule_set_t,
    pub mirror_rule_reset: eth_mirror_rule_reset_t,
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    pub l2_tunnel_eth_type_conf: eth_l2_tunnel_eth_type_conf_t,
    pub l2_tunnel_offload_set: eth_l2_tunnel_offload_set_t,
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    pub rss_hash_update: rss_hash_update_t,
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    pub reta_update: reta_update_t,
    pub reta_query: reta_query_t,
    pub get_reg: eth_get_reg_t,
    pub get_eeprom_length: eth_get_eeprom_length_t,
    pub get_eeprom: eth_get_eeprom_t,
    pub set_eeprom: eth_set_eeprom_t,
    pub get_module_info: eth_get_module_info_t,
    pub get_module_eeprom: eth_get_module_eeprom_t,
    pub filter_ctrl: eth_filter_ctrl_t,
    pub get_dcb_info: eth_get_dcb_info,
    pub timesync_enable: eth_timesync_enable_t,
    pub timesync_disable: eth_timesync_disable_t,
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    pub timesync_adjust_time: eth_timesync_adjust_time,
    pub timesync_read_time: eth_timesync_read_time,
    pub timesync_write_time: eth_timesync_write_time,
    pub read_clock: eth_read_clock,
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    pub tm_ops_get: eth_tm_ops_get_t,
    pub mtr_ops_get: eth_mtr_ops_get_t,
    pub pool_ops_supported: eth_pool_ops_supported_t,
    pub hairpin_cap_get: eth_hairpin_cap_get_t,
    pub rx_hairpin_queue_setup: eth_rx_hairpin_queue_setup_t,
    pub tx_hairpin_queue_setup: eth_tx_hairpin_queue_setup_t,
}
#[test]
fn bindgen_test_layout_eth_dev_ops() {
    assert_eq!(
        ::std::mem::size_of::<eth_dev_ops>(),
        752usize,
        concat!("Size of: ", stringify!(eth_dev_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<eth_dev_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(eth_dev_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_configure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_stop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_set_link_up as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_set_link_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_set_link_down as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_set_link_down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_reset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).link_update as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(link_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).is_removed as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(is_removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).promiscuous_enable as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(promiscuous_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).promiscuous_disable as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(promiscuous_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).allmulticast_enable as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(allmulticast_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).allmulticast_disable as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(allmulticast_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_remove as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_add as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_set as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).set_mc_addr_list as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_mc_addr_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mtu_set as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mtu_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).stats_get as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(stats_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).stats_reset as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(stats_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_reset as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_names as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).queue_stats_mapping_set as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(queue_stats_mapping_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_infos_get as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_infos_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rxq_info_get as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rxq_info_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).txq_info_get as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(txq_info_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_burst_mode_get as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_burst_mode_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_burst_mode_get as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_burst_mode_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).fw_version_get as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(fw_version_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).dev_supported_ptypes_get as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_supported_ptypes_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_ptypes_set as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_ptypes_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_filter_set as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_filter_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_tpid_set as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_tpid_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).vlan_strip_queue_set as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_strip_queue_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_offload_set as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_offload_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_pvid_set as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_pvid_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_start as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_stop as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_start as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_stop as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_setup as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_release as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_count as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_descriptor_done as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_descriptor_done)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_descriptor_status as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).tx_descriptor_status as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_intr_enable as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_intr_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_intr_disable as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_intr_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_setup as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_release as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_done_cleanup as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_done_cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_led_on as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_led_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_led_off as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_led_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).flow_ctrl_get as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(flow_ctrl_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).flow_ctrl_set as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(flow_ctrl_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).priority_flow_ctrl_set as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(priority_flow_ctrl_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).uc_hash_table_set as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(uc_hash_table_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).uc_all_hash_table_set as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(uc_all_hash_table_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mirror_rule_set as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mirror_rule_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mirror_rule_reset as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mirror_rule_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).udp_tunnel_port_add as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(udp_tunnel_port_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).udp_tunnel_port_del as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(udp_tunnel_port_del)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).l2_tunnel_eth_type_conf as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(l2_tunnel_eth_type_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).l2_tunnel_offload_set as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(l2_tunnel_offload_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).set_queue_rate_limit as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_queue_rate_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rss_hash_update as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rss_hash_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rss_hash_conf_get as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rss_hash_conf_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).reta_update as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(reta_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).reta_query as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(reta_query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_reg as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_eeprom_length as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_eeprom_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_eeprom as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).set_eeprom as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_module_info as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_module_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_module_eeprom as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_module_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).filter_ctrl as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(filter_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_dcb_info as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_dcb_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_enable as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_disable as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_disable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_rx_timestamp as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_rx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_tx_timestamp as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_tx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_adjust_time as *const _ as usize
        },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_adjust_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_time as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_write_time as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_write_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).read_clock as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(read_clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_by_id as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_by_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_names_by_id as *const _ as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_names_by_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tm_ops_get as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tm_ops_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mtr_ops_get as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mtr_ops_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).pool_ops_supported as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(pool_ops_supported)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).hairpin_cap_get as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(hairpin_cap_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_hairpin_queue_setup as *const _ as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_hairpin_queue_setup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).tx_hairpin_queue_setup as *const _ as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_hairpin_queue_setup)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).rx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).tx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(tx)
        )
    );
}
impl Default for rte_eth_rxtx_callback__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).fn_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(param)
        )
    );
}
impl Default for rte_eth_rxtx_callback {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev {
    pub rx_pkt_burst: eth_rx_burst_t,
    pub tx_pkt_burst: eth_tx_burst_t,
    pub tx_pkt_prepare: eth_tx_prep_t,
    pub data: *mut rte_eth_dev_data,
    pub process_private: *mut ::std::os::raw::c_void,
    pub dev_ops: *const eth_dev_ops,
    pub device: *mut rte_device,
    pub intr_handle: *mut rte_intr_handle,
    pub link_intr_cbs: rte_eth_dev_cb_list,
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    pub state: rte_eth_dev_state::Type,
    pub security_ctx: *mut ::std::os::raw::c_void,
    pub reserved_64s: [u64; 4usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev>(),
        16576usize,
        concat!("Size of: ", stringify!(rte_eth_dev))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_dev))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).rx_pkt_burst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(rx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_burst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_prepare as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).process_private as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(process_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).dev_ops as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(dev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).device as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).intr_handle as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(intr_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).link_intr_cbs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(link_intr_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).post_rx_burst_cbs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(post_rx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).pre_tx_burst_cbs as *const _ as usize },
        8272usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(pre_tx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).state as *const _ as usize },
        16464usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).security_ctx as *const _ as usize },
        16472usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(security_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).reserved_64s as *const _ as usize },
        16480usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).reserved_ptrs as *const _ as usize },
        16512usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_dev {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    pub name: [::std::os::raw::c_char; 64usize],
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    pub nb_rx_queues: u16,
    pub nb_tx_queues: u16,
    pub sriov: rte_eth_dev_sriov,
    pub dev_private: *mut ::std::os::raw::c_void,
    pub dev_link: rte_eth_link,
    pub dev_conf: rte_eth_conf,
    pub mtu: u16,
    pub min_rx_buf_size: u32,
    pub rx_mbuf_alloc_failed: u64,
    pub mac_addrs: *mut rte_ether_addr,
    pub mac_pool_sel: [u64; 128usize],
    pub hash_mac_addrs: *mut rte_ether_addr,
    pub port_id: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rx_queue_state: [u8; 1024usize],
    pub tx_queue_state: [u8; 1024usize],
    pub dev_flags: u32,
    pub kdrv: rte_kernel_driver::Type,
    pub numa_node: ::std::os::raw::c_int,
    pub vlan_filter_conf: rte_vlan_filter_conf,
    pub owner: rte_eth_dev_owner,
    pub representor_id: u16,
    pub reserved_64s: [u64; 4usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_data>(),
        6976usize,
        concat!("Size of: ", stringify!(rte_eth_dev_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_data>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queues as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queues as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_rx_queues as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_tx_queues as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).sriov as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(sriov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_private as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_link as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_conf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mtu as *const _ as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).min_rx_buf_size as *const _ as usize
        },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(min_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_mbuf_alloc_failed as *const _ as usize
        },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_mbuf_alloc_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_addrs as *const _ as usize },
        3208usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_pool_sel as *const _ as usize },
        3216usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_pool_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).hash_mac_addrs as *const _ as usize },
        4240usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).port_id as *const _ as usize },
        4248usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queue_state as *const _ as usize },
        4251usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queue_state as *const _ as usize },
        5275usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_flags as *const _ as usize },
        6300usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).kdrv as *const _ as usize },
        6304usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(kdrv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).numa_node as *const _ as usize },
        6308usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).vlan_filter_conf as *const _ as usize
        },
        6312usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(vlan_filter_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).owner as *const _ as usize },
        6824usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).representor_id as *const _ as usize },
        6896usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(representor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).reserved_64s as *const _ as usize },
        6904usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).reserved_ptrs as *const _ as usize },
        6936usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_dev_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut rte_eth_devices: [rte_eth_dev; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pci_id {
    pub class_id: u32,
    pub vendor_id: u16,
    pub device_id: u16,
    pub subsystem_vendor_id: u16,
    pub subsystem_device_id: u16,
}
#[test]
fn bindgen_test_layout_rte_pci_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_id>(),
        12usize,
        concat!("Size of: ", stringify!(rte_pci_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).class_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).vendor_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).device_id as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_vendor_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_device_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_device_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pci_addr {
    pub domain: u32,
    pub bus: u8,
    pub devid: u8,
    pub function: u8,
}
#[test]
fn bindgen_test_layout_rte_pci_addr() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_addr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).bus as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).devid as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).function as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(function)
        )
    );
}
extern "C" {
    pub fn rte_pci_device_name(
        addr: *const rte_pci_addr,
        output: *mut ::std::os::raw::c_char,
        size: size_t,
    );
}
extern "C" {
    pub fn rte_pci_addr_cmp(
        addr: *const rte_pci_addr,
        addr2: *const rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_pci_addr_parse(
        str: *const ::std::os::raw::c_char,
        addr: *mut rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_kni_req_id {
    pub type Type = u32;
    pub const RTE_KNI_REQ_UNKNOWN: Type = 0;
    pub const RTE_KNI_REQ_CHANGE_MTU: Type = 1;
    pub const RTE_KNI_REQ_CFG_NETWORK_IF: Type = 2;
    pub const RTE_KNI_REQ_CHANGE_MAC_ADDR: Type = 3;
    pub const RTE_KNI_REQ_CHANGE_PROMISC: Type = 4;
    pub const RTE_KNI_REQ_CHANGE_ALLMULTI: Type = 5;
    pub const RTE_KNI_REQ_MAX: Type = 6;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_kni_request {
    pub req_id: u32,
    pub __bindgen_anon_1: rte_kni_request__bindgen_ty_1,
    pub result: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_kni_request__bindgen_ty_1 {
    pub new_mtu: u32,
    pub if_up: u8,
    pub mac_addr: [u8; 6usize],
    pub promiscusity: u8,
    pub allmulti: u8,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_rte_kni_request__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_request__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_kni_request__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_request__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_kni_request__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).new_mtu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(new_mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).if_up as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(if_up)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).mac_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).promiscusity as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(promiscusity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).allmulti as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(allmulti)
        )
    );
}
impl Default for rte_kni_request__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_kni_request() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_request>(),
        16usize,
        concat!("Size of: ", stringify!(rte_kni_request))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_request>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_kni_request))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request>())).req_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request),
            "::",
            stringify!(req_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request>())).result as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request),
            "::",
            stringify!(result)
        )
    );
}
impl Default for rte_kni_request {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rte_kni_fifo {
    pub write: ::std::os::raw::c_uint,
    pub read: ::std::os::raw::c_uint,
    pub len: ::std::os::raw::c_uint,
    pub elem_size: ::std::os::raw::c_uint,
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_rte_kni_fifo() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_fifo>(),
        16usize,
        concat!("Size of: ", stringify!(rte_kni_fifo))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_fifo>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_fifo))
    );
}
impl Default for rte_kni_fifo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_kni_mbuf {
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub buf_physaddr: u64,
    pub data_off: u16,
    pub pad1: [::std::os::raw::c_char; 2usize],
    pub nb_segs: u16,
    pub pad4: [::std::os::raw::c_char; 2usize],
    pub ol_flags: u64,
    pub pad2: [::std::os::raw::c_char; 4usize],
    pub pkt_len: u32,
    pub data_len: u16,
    pub __bindgen_padding_0: [u8; 22usize],
    pub pad3: [::std::os::raw::c_char; 8usize],
    pub pool: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_kni_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_kni_mbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_mbuf>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_kni_mbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).buf_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).buf_physaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(buf_physaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).data_off as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).nb_segs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(nb_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad4 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).ol_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pkt_len as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).data_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad3 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pool as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).next as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(next)
        )
    );
}
impl Default for rte_kni_mbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_kni_device_info {
    pub name: [::std::os::raw::c_char; 16usize],
    pub tx_phys: phys_addr_t,
    pub rx_phys: phys_addr_t,
    pub alloc_phys: phys_addr_t,
    pub free_phys: phys_addr_t,
    pub req_phys: phys_addr_t,
    pub resp_phys: phys_addr_t,
    pub sync_phys: phys_addr_t,
    pub sync_va: *mut ::std::os::raw::c_void,
    pub mbuf_va: *mut ::std::os::raw::c_void,
    pub mbuf_phys: phys_addr_t,
    pub group_id: u16,
    pub core_id: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub mtu: ::std::os::raw::c_uint,
    pub min_mtu: ::std::os::raw::c_uint,
    pub max_mtu: ::std::os::raw::c_uint,
    pub mac_addr: [u8; 6usize],
    pub iova_mode: u8,
}
#[test]
fn bindgen_test_layout_rte_kni_device_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_device_info>(),
        136usize,
        concat!("Size of: ", stringify!(rte_kni_device_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_device_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_device_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).tx_phys as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(tx_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).rx_phys as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(rx_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).alloc_phys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(alloc_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).free_phys as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(free_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).req_phys as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(req_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).resp_phys as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(resp_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).sync_phys as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(sync_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).sync_va as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(sync_va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_va as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_phys as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).group_id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).core_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_size as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mtu as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).min_mtu as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(min_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).max_mtu as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mac_addr as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).iova_mode as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(iova_mode)
        )
    );
}
impl Default for rte_kni_device_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_kni_device_info {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_kni_ops {
    pub port_id: u16,
    pub change_mtu: ::std::option::Option<
        unsafe extern "C" fn(
            port_id: u16,
            new_mtu: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub config_network_if: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, if_up: u8) -> ::std::os::raw::c_int,
    >,
    pub config_mac_address: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, mac_addr: *mut u8) -> ::std::os::raw::c_int,
    >,
    pub config_promiscusity: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, to_on: u8) -> ::std::os::raw::c_int,
    >,
    pub config_allmulticast: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, to_on: u8) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rte_kni_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_ops>(),
        48usize,
        concat!("Size of: ", stringify!(rte_kni_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).port_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).change_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(change_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_network_if as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_network_if)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_mac_address as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_mac_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_promiscusity as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_promiscusity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_allmulticast as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_allmulticast)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_kni_conf {
    pub name: [::std::os::raw::c_char; 16usize],
    pub core_id: u32,
    pub group_id: u16,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub addr: rte_pci_addr,
    pub id: rte_pci_id,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub mac_addr: [u8; 6usize],
    pub mtu: u16,
    pub min_mtu: u16,
    pub max_mtu: u16,
}
#[test]
fn bindgen_test_layout_rte_kni_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_conf>(),
        64usize,
        concat!("Size of: ", stringify!(rte_kni_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_kni_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).core_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).group_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mbuf_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).addr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mac_addr as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mtu as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).min_mtu as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(min_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).max_mtu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(max_mtu)
        )
    );
}
impl rte_kni_conf {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn rte_kni_init(max_kni_ifaces: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_kni_alloc(
        pktmbuf_pool: *mut rte_mempool,
        conf: *const rte_kni_conf,
        ops: *mut rte_kni_ops,
    ) -> *mut rte_kni;
}
extern "C" {
    pub fn rte_kni_release(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_kni_handle_request(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_kni_rx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_kni_tx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_kni_get(name: *const ::std::os::raw::c_char) -> *mut rte_kni;
}
extern "C" {
    pub fn rte_kni_get_name(kni: *const rte_kni) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_kni_register_handlers(
        kni: *mut rte_kni,
        ops: *mut rte_kni_ops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_kni_unregister_handlers(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_kni_update_link(
        kni: *mut rte_kni,
        linkup: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_kni_close();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct nodemask_t {
    pub n: [::std::os::raw::c_ulong; 2usize],
}
#[test]
fn bindgen_test_layout_nodemask_t() {
    assert_eq!(
        ::std::mem::size_of::<nodemask_t>(),
        16usize,
        concat!("Size of: ", stringify!(nodemask_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nodemask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nodemask_t>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_t),
            "::",
            stringify!(n)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct bitmask {
    pub size: ::std::os::raw::c_ulong,
    pub maskp: *mut ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_bitmask() {
    assert_eq!(
        ::std::mem::size_of::<bitmask>(),
        16usize,
        concat!("Size of: ", stringify!(bitmask))
    );
    assert_eq!(
        ::std::mem::align_of::<bitmask>(),
        8usize,
        concat!("Alignment of ", stringify!(bitmask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitmask>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitmask),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitmask>())).maskp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bitmask),
            "::",
            stringify!(maskp)
        )
    );
}
impl Default for bitmask {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn numa_bitmask_isbitset(
        arg1: *const bitmask,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_bitmask_setall(arg1: *mut bitmask) -> *mut bitmask;
}
extern "C" {
    pub fn numa_bitmask_clearall(arg1: *mut bitmask) -> *mut bitmask;
}
extern "C" {
    pub fn numa_bitmask_setbit(arg1: *mut bitmask, arg2: ::std::os::raw::c_uint) -> *mut bitmask;
}
extern "C" {
    pub fn numa_bitmask_clearbit(arg1: *mut bitmask, arg2: ::std::os::raw::c_uint) -> *mut bitmask;
}
extern "C" {
    pub fn numa_bitmask_nbytes(arg1: *mut bitmask) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn numa_bitmask_weight(arg1: *const bitmask) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn numa_bitmask_alloc(arg1: ::std::os::raw::c_uint) -> *mut bitmask;
}
extern "C" {
    pub fn numa_bitmask_free(arg1: *mut bitmask);
}
extern "C" {
    pub fn numa_bitmask_equal(arg1: *const bitmask, arg2: *const bitmask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_available() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_max_node() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_max_possible_node() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_preferred() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_node_size64(
        node: ::std::os::raw::c_int,
        freep: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn numa_node_size(
        node: ::std::os::raw::c_int,
        freep: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn numa_pagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_bind(nodes: *mut bitmask);
}
extern "C" {
    pub fn numa_set_interleave_mask(nodemask: *mut bitmask);
}
extern "C" {
    pub fn numa_get_interleave_mask() -> *mut bitmask;
}
extern "C" {
    pub fn numa_allocate_nodemask() -> *mut bitmask;
}
extern "C" {
    pub fn numa_set_preferred(node: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_set_localalloc();
}
extern "C" {
    pub fn numa_set_membind(nodemask: *mut bitmask);
}
extern "C" {
    pub fn numa_get_membind() -> *mut bitmask;
}
extern "C" {
    pub fn numa_get_mems_allowed() -> *mut bitmask;
}
extern "C" {
    pub fn numa_get_interleave_node() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_alloc_interleaved_subset(
        size: size_t,
        nodemask: *mut bitmask,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn numa_alloc_interleaved(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn numa_alloc_onnode(
        size: size_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn numa_alloc_local(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn numa_alloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn numa_realloc(
        old_addr: *mut ::std::os::raw::c_void,
        old_size: size_t,
        new_size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn numa_free(mem: *mut ::std::os::raw::c_void, size: size_t);
}
extern "C" {
    pub fn numa_interleave_memory(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
        mask: *mut bitmask,
    );
}
extern "C" {
    pub fn numa_tonode_memory(
        start: *mut ::std::os::raw::c_void,
        size: size_t,
        node: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn numa_tonodemask_memory(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
        mask: *mut bitmask,
    );
}
extern "C" {
    pub fn numa_setlocal_memory(start: *mut ::std::os::raw::c_void, size: size_t);
}
extern "C" {
    pub fn numa_police_memory(start: *mut ::std::os::raw::c_void, size: size_t);
}
extern "C" {
    pub fn numa_run_on_node_mask(mask: *mut bitmask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_run_on_node_mask_all(mask: *mut bitmask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_run_on_node(node: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_get_run_node_mask() -> *mut bitmask;
}
extern "C" {
    pub fn numa_set_bind_policy(strict: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_set_strict(flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_num_possible_nodes() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_num_possible_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_num_configured_nodes() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_num_configured_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_num_task_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_num_thread_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_num_task_nodes() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_num_thread_nodes() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_allocate_cpumask() -> *mut bitmask;
}
extern "C" {
    pub fn numa_node_to_cpus(
        arg1: ::std::os::raw::c_int,
        arg2: *mut bitmask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_node_of_cpu(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_distance(
        node1: ::std::os::raw::c_int,
        node2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_error(where_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn numa_warn(num: ::std::os::raw::c_int, fmt: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn numa_migrate_pages(
        pid: ::std::os::raw::c_int,
        from: *mut bitmask,
        to: *mut bitmask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_move_pages(
        pid: ::std::os::raw::c_int,
        count: ::std::os::raw::c_ulong,
        pages: *mut *mut ::std::os::raw::c_void,
        nodes: *const ::std::os::raw::c_int,
        status: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_sched_getaffinity(arg1: pid_t, arg2: *mut bitmask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_sched_setaffinity(arg1: pid_t, arg2: *mut bitmask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_parse_nodestring(arg1: *const ::std::os::raw::c_char) -> *mut bitmask;
}
extern "C" {
    pub fn numa_parse_nodestring_all(arg1: *const ::std::os::raw::c_char) -> *mut bitmask;
}
extern "C" {
    pub fn numa_parse_cpustring(arg1: *const ::std::os::raw::c_char) -> *mut bitmask;
}
extern "C" {
    pub fn numa_parse_cpustring_all(arg1: *const ::std::os::raw::c_char) -> *mut bitmask;
}
pub type bpf_int32 = ::std::os::raw::c_int;
pub type bpf_u_int32 = u_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct bpf_program {
    pub bf_len: u_int,
    pub bf_insns: *mut bpf_insn,
}
#[test]
fn bindgen_test_layout_bpf_program() {
    assert_eq!(
        ::std::mem::size_of::<bpf_program>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_program))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_program>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_program))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_program>())).bf_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_program),
            "::",
            stringify!(bf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_program>())).bf_insns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_program),
            "::",
            stringify!(bf_insns)
        )
    );
}
impl Default for bpf_program {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct bpf_insn {
    pub code: u_short,
    pub jt: u_char,
    pub jf: u_char,
    pub k: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_bpf_insn() {
    assert_eq!(
        ::std::mem::size_of::<bpf_insn>(),
        8usize,
        concat!("Size of: ", stringify!(bpf_insn))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_insn>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_insn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).jt as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(jt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).jf as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(jf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).k as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(k)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcap {
    _unused: [u8; 0],
}
pub type pcap_t = pcap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcap_dumper {
    _unused: [u8; 0],
}
pub type pcap_dumper_t = pcap_dumper;
pub type pcap_if_t = pcap_if;
pub type pcap_addr_t = pcap_addr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct pcap_file_header {
    pub magic: bpf_u_int32,
    pub version_major: u_short,
    pub version_minor: u_short,
    pub thiszone: bpf_int32,
    pub sigfigs: bpf_u_int32,
    pub snaplen: bpf_u_int32,
    pub linktype: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_pcap_file_header() {
    assert_eq!(
        ::std::mem::size_of::<pcap_file_header>(),
        24usize,
        concat!("Size of: ", stringify!(pcap_file_header))
    );
    assert_eq!(
        ::std::mem::align_of::<pcap_file_header>(),
        4usize,
        concat!("Alignment of ", stringify!(pcap_file_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_file_header>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_file_header),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_file_header>())).version_major as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_file_header),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_file_header>())).version_minor as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_file_header),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_file_header>())).thiszone as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_file_header),
            "::",
            stringify!(thiszone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_file_header>())).sigfigs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_file_header),
            "::",
            stringify!(sigfigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_file_header>())).snaplen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_file_header),
            "::",
            stringify!(snaplen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_file_header>())).linktype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_file_header),
            "::",
            stringify!(linktype)
        )
    );
}
pub mod pcap_direction_t {
    pub type Type = u32;
    pub const PCAP_D_INOUT: Type = 0;
    pub const PCAP_D_IN: Type = 1;
    pub const PCAP_D_OUT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct pcap_pkthdr {
    pub ts: timeval,
    pub caplen: bpf_u_int32,
    pub len: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_pcap_pkthdr() {
    assert_eq!(
        ::std::mem::size_of::<pcap_pkthdr>(),
        24usize,
        concat!("Size of: ", stringify!(pcap_pkthdr))
    );
    assert_eq!(
        ::std::mem::align_of::<pcap_pkthdr>(),
        8usize,
        concat!("Alignment of ", stringify!(pcap_pkthdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_pkthdr>())).ts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_pkthdr),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_pkthdr>())).caplen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_pkthdr),
            "::",
            stringify!(caplen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_pkthdr>())).len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_pkthdr),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct pcap_stat {
    pub ps_recv: u_int,
    pub ps_drop: u_int,
    pub ps_ifdrop: u_int,
}
#[test]
fn bindgen_test_layout_pcap_stat() {
    assert_eq!(
        ::std::mem::size_of::<pcap_stat>(),
        12usize,
        concat!("Size of: ", stringify!(pcap_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<pcap_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(pcap_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_stat>())).ps_recv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_stat),
            "::",
            stringify!(ps_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_stat>())).ps_drop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_stat),
            "::",
            stringify!(ps_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_stat>())).ps_ifdrop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_stat),
            "::",
            stringify!(ps_ifdrop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct pcap_if {
    pub next: *mut pcap_if,
    pub name: *mut ::std::os::raw::c_char,
    pub description: *mut ::std::os::raw::c_char,
    pub addresses: *mut pcap_addr,
    pub flags: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_pcap_if() {
    assert_eq!(
        ::std::mem::size_of::<pcap_if>(),
        40usize,
        concat!("Size of: ", stringify!(pcap_if))
    );
    assert_eq!(
        ::std::mem::align_of::<pcap_if>(),
        8usize,
        concat!("Alignment of ", stringify!(pcap_if))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_if>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_if),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_if>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_if),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_if>())).description as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_if),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_if>())).addresses as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_if),
            "::",
            stringify!(addresses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_if>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_if),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for pcap_if {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct pcap_addr {
    pub next: *mut pcap_addr,
    pub addr: *mut sockaddr,
    pub netmask: *mut sockaddr,
    pub broadaddr: *mut sockaddr,
    pub dstaddr: *mut sockaddr,
}
#[test]
fn bindgen_test_layout_pcap_addr() {
    assert_eq!(
        ::std::mem::size_of::<pcap_addr>(),
        40usize,
        concat!("Size of: ", stringify!(pcap_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<pcap_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(pcap_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_addr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_addr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_addr>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_addr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_addr>())).netmask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_addr),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_addr>())).broadaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_addr),
            "::",
            stringify!(broadaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcap_addr>())).dstaddr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_addr),
            "::",
            stringify!(dstaddr)
        )
    );
}
impl Default for pcap_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pcap_handler = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut u_char, arg2: *const pcap_pkthdr, arg3: *const u_char),
>;
extern "C" {
    pub fn pcap_lookupdev(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_lookupnet(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut bpf_u_int32,
        arg3: *mut bpf_u_int32,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_create(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_set_snaplen(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_promisc(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_can_set_rfmon(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_rfmon(arg1: *mut pcap_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_timeout(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_tstamp_type(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_immediate_mode(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_buffer_size(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_tstamp_precision(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_get_tstamp_precision(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_activate(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_list_tstamp_types(
        arg1: *mut pcap_t,
        arg2: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_free_tstamp_types(arg1: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcap_tstamp_type_name_to_val(
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_tstamp_type_val_to_name(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_tstamp_type_val_to_description(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_open_live(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_char,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_open_dead(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_open_dead_with_tstamp_precision(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: u_int,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_open_offline_with_tstamp_precision(
        arg1: *const ::std::os::raw::c_char,
        arg2: u_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_open_offline(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_fopen_offline_with_tstamp_precision(
        arg1: *mut FILE,
        arg2: u_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_fopen_offline(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_close(arg1: *mut pcap_t);
}
extern "C" {
    pub fn pcap_loop(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
        arg3: pcap_handler,
        arg4: *mut u_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_dispatch(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
        arg3: pcap_handler,
        arg4: *mut u_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_next(arg1: *mut pcap_t, arg2: *mut pcap_pkthdr) -> *const u_char;
}
extern "C" {
    pub fn pcap_next_ex(
        arg1: *mut pcap_t,
        arg2: *mut *mut pcap_pkthdr,
        arg3: *mut *const u_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_breakloop(arg1: *mut pcap_t);
}
extern "C" {
    pub fn pcap_stats(arg1: *mut pcap_t, arg2: *mut pcap_stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_setfilter(arg1: *mut pcap_t, arg2: *mut bpf_program) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_setdirection(
        arg1: *mut pcap_t,
        arg2: pcap_direction_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_getnonblock(
        arg1: *mut pcap_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_setnonblock(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_inject(
        arg1: *mut pcap_t,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_sendpacket(
        arg1: *mut pcap_t,
        arg2: *const u_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_statustostr(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_strerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_geterr(arg1: *mut pcap_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_perror(arg1: *mut pcap_t, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn pcap_compile(
        arg1: *mut pcap_t,
        arg2: *mut bpf_program,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: bpf_u_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_compile_nopcap(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut bpf_program,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
        arg6: bpf_u_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_freecode(arg1: *mut bpf_program);
}
extern "C" {
    pub fn pcap_offline_filter(
        arg1: *const bpf_program,
        arg2: *const pcap_pkthdr,
        arg3: *const u_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_datalink(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_datalink_ext(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_list_datalinks(
        arg1: *mut pcap_t,
        arg2: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_set_datalink(
        arg1: *mut pcap_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_free_datalinks(arg1: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcap_datalink_name_to_val(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_datalink_val_to_name(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_datalink_val_to_description(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_snapshot(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_is_swapped(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_major_version(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_minor_version(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_file(arg1: *mut pcap_t) -> *mut FILE;
}
extern "C" {
    pub fn pcap_fileno(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_dump_open(
        arg1: *mut pcap_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut pcap_dumper_t;
}
extern "C" {
    pub fn pcap_dump_fopen(arg1: *mut pcap_t, fp: *mut FILE) -> *mut pcap_dumper_t;
}
extern "C" {
    pub fn pcap_dump_open_append(
        arg1: *mut pcap_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut pcap_dumper_t;
}
extern "C" {
    pub fn pcap_dump_file(arg1: *mut pcap_dumper_t) -> *mut FILE;
}
extern "C" {
    pub fn pcap_dump_ftell(arg1: *mut pcap_dumper_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pcap_dump_flush(arg1: *mut pcap_dumper_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_dump_close(arg1: *mut pcap_dumper_t);
}
extern "C" {
    pub fn pcap_dump(arg1: *mut u_char, arg2: *const pcap_pkthdr, arg3: *const u_char);
}
extern "C" {
    pub fn pcap_findalldevs(
        arg1: *mut *mut pcap_if_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcap_freealldevs(arg1: *mut pcap_if_t);
}
extern "C" {
    pub fn pcap_lib_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pcap_get_selectable_fd(arg1: *mut pcap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Error number value, stored per-thread, which can be queried after"]
    #[doc = " calls to certain functions to determine why those functions failed."]
    pub fn _rte_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new mbuf from a mempool."]
    pub fn _rte_pktmbuf_alloc(mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Free a packet mbuf back into its original mempool."]
    pub fn _rte_pktmbuf_free(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Allocate a bulk of mbufs, initialize refcnt and reset the fields to"]
    #[doc = " default values."]
    pub fn _rte_pktmbuf_alloc_bulk(
        pool: *mut rte_mempool,
        mbufs: *mut *mut rte_mbuf,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put several objects back in the mempool."]
    pub fn _rte_mempool_put_bulk(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Retrieve a burst of input packets from a receive queue of an Ethernet"]
    #[doc = " device. The retrieved packets are stored in *rte_mbuf* structures whose"]
    #[doc = " pointers are supplied in the *rx_pkts* array."]
    pub fn _rte_eth_rx_burst(
        port_id: u16,
        queue_id: u16,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Send a burst of output packets on a transmit queue of an Ethernet device."]
    pub fn _rte_eth_tx_burst(
        port_id: u16,
        queue_id: u16,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_class {
    pub _address: u8,
}
